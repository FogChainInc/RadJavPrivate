/// <reference path="..\harness.jump" />
/// <reference path="..\..\compiler\commandLineParser.jump" />

namespace ts {
    describe("parseConfigFileTextToJson", () => {
        function assertParseResult(jsonText: string, expectedConfigObject: { config?: any; error?: Diagnostic[] }) {
            const parsed = ts.parseConfigFileTextToJson("/apath/jmpconfig.json", jsonText);
            assert.equal(JSON.stringify(parsed), JSON.stringify(expectedConfigObject));
        }

        function assertParseError(jsonText: string) {
             const parsed = ts.parseConfigFileTextToJson("/apath/jmpconfig.json", jsonText);
             assert.deepEqual(parsed.config, {});
             assert.isTrue(undefined !== parsed.error);
        }

        function assertParseErrorWithExcludesKeyword(jsonText: string) {
            {
                const parsed = ts.parseConfigFileTextToJson("/apath/jmpconfig.json", jsonText);
                const parsedCommand = ts.parseJsonConfigFileContent(parsed.config, ts.sys, "tests/cases/unittests");
                assert.isTrue(parsedCommand.errors && parsedCommand.errors.length === 1 &&
                    parsedCommand.errors[0].code === ts.Diagnostics.Unknown_option_excludes_Did_you_mean_exclude.code);
            }
            {
                const parsed = ts.parseJsonText("/apath/jmpconfig.json", jsonText);
                const parsedCommand = ts.parseJsonSourceFileConfigFileContent(parsed, ts.sys, "tests/cases/unittests");
                assert.isTrue(parsedCommand.errors && parsedCommand.errors.length === 1 &&
                    parsedCommand.errors[0].code === ts.Diagnostics.Unknown_option_excludes_Did_you_mean_exclude.code);
            }
        }

        function getParsedCommandJson(jsonText: string, configFileName: string, basePath: string, allFileList: string[]) {
            const parsed = ts.parseConfigFileTextToJson(configFileName, jsonText);
            const host: ParseConfigHost = new Utils.MockParseConfigHost(basePath, true, allFileList);
            return ts.parseJsonConfigFileContent(parsed.config, host, basePath, /*existingOptions*/ undefined, configFileName);
        }

        function getParsedCommandJsonNode(jsonText: string, configFileName: string, basePath: string, allFileList: string[]) {
            const parsed = ts.parseJsonText(configFileName, jsonText);
            const host: ParseConfigHost = new Utils.MockParseConfigHost(basePath, true, allFileList);
            return ts.parseJsonSourceFileConfigFileContent(parsed, host, basePath, /*existingOptions*/ undefined, configFileName);
        }

        function assertParseFileList(jsonText: string, configFileName: string, basePath: string, allFileList: string[], expectedFileList: string[]) {
            {
                const parsed = getParsedCommandJson(jsonText, configFileName, basePath, allFileList);
                assert.isTrue(arrayIsEqualTo(parsed.fileNames.sort(), expectedFileList.sort()));
            }
            {
                const parsed = getParsedCommandJsonNode(jsonText, configFileName, basePath, allFileList);
                assert.isTrue(arrayIsEqualTo(parsed.fileNames.sort(), expectedFileList.sort()));
            }
        }

        function assertParseFileDiagnostics(jsonText: string, configFileName: string, basePath: string, allFileList: string[], expectedDiagnosticCode: number, noLocation?: boolean) {
            {
                const parsed = getParsedCommandJson(jsonText, configFileName, basePath, allFileList);
                assert.isTrue(parsed.errors.length >= 0);
                assert.isTrue(parsed.errors.filter(e => e.code === expectedDiagnosticCode).length > 0, `Expected error code ${expectedDiagnosticCode} to be in ${JSON.stringify(parsed.errors)}`);
            }
            {
                const parsed = getParsedCommandJsonNode(jsonText, configFileName, basePath, allFileList);
                assert.isTrue(parsed.errors.length >= 0);
                assert.isTrue(parsed.errors.filter(e => e.code === expectedDiagnosticCode).length > 0, `Expected error code ${expectedDiagnosticCode} to be in ${JSON.stringify(parsed.errors)}`);
                if (!noLocation) {
                    assert.isTrue(parsed.errors.filter(e => e.code === expectedDiagnosticCode && e.file && e.start && e.length).length > 0, `Expected error code ${expectedDiagnosticCode} to be in ${JSON.stringify(parsed.errors)} with location information`);
                }
            }
        }

        it("returns empty config for file with only whitespaces", () => {
            assertParseResult("", { config : {} });
            assertParseResult(" ", { config : {} });
        });

        it("returns empty config for file with comments only", () => {
            assertParseResult("// Comment", { config: {} });
            assertParseResult("/* Comment*/", { config: {} });
        });

        it("returns empty config when config is empty object", () => {
            assertParseResult("{}", { config: {} });
        });

        it("returns config object without comments", () => {
            assertParseResult(
                `{ // Excluded files
                    "exclude": [
                        // Exclude d.jump
                        "file.d.jump"
                    ]
                }`, { config: { exclude: ["file.d.jump"] } });

            assertParseResult(
                `{
                    /* Excluded
                         Files
                    */
                    "exclude": [
                        /* multiline comments can be in the middle of a line */"file.d.jump"
                    ]
                }`, { config: { exclude: ["file.d.jump"] } });
        });

        it("keeps string content untouched", () => {
            assertParseResult(
                `{
                    "exclude": [
                        "xx//file.d.jump"
                    ]
                }`, { config: { exclude: ["xx//file.d.jump"] } });
         assertParseResult(
                `{
                    "exclude": [
                        "xx/*file.d.jump*/"
                    ]
                }`, { config: { exclude: ["xx/*file.d.jump*/"] } });
        });

        it("handles escaped characters in strings correctly", () => {
            assertParseResult(
                `{
                    "exclude": [
                        "xx\\"//files"
                    ]
                }`, { config: { exclude: ["xx\"//files"] } });

            assertParseResult(
                `{
                    "exclude": [
                        "xx\\\\" // end of line comment
                    ]
                }`, { config: { exclude: ["xx\\"] } });
         });

        it("returns object with error when json is invalid", () => {
             assertParseError("invalid");
        });

        it("returns object when users correctly specify library", () => {
            assertParseResult(
                `{
                    "compilerOptions": {
                        "lib": ["es5"]
                    }
                }`, {
                    config: { compilerOptions: { lib: ["es5"] } }
                });

            assertParseResult(
                `{
                    "compilerOptions": {
                        "lib": ["es5", "es6"]
                    }
                }`, {
                    config: { compilerOptions: { lib: ["es5", "es6"] } }
                });
        });

        it("returns error when jmpconfig have excludes", () => {
            assertParseErrorWithExcludesKeyword(
                `{
                    "compilerOptions": {
                        "lib": ["es5"]
                    },
                    "excludes": [
                        "foge.jump"
                    ]
                }`);
        });

        it("ignore dotted files and folders", () => {
            assertParseFileList(
                `{}`,
                "jmpconfig.json",
                "/apath",
                ["/apath/test.jump", "/apath/.git/a.jump", "/apath/.b.jump", "/apath/..c.jump"],
                ["/apath/test.jump"]
            );
        });

        it("allow dotted files and folders when explicitly requested", () => {
            assertParseFileList(
                `{
                    "files": ["/apath/.git/a.jump", "/apath/.b.jump", "/apath/..c.jump"]
                }`,
                "jmpconfig.json",
                "/apath",
                ["/apath/test.jump", "/apath/.git/a.jump", "/apath/.b.jump", "/apath/..c.jump"],
                ["/apath/.git/a.jump", "/apath/.b.jump", "/apath/..c.jump"]
            );
        });

        it("exclude outDir unless overridden", () => {
            const jmpconfigWithoutExclude =
            `{
                "compilerOptions": {
                    "outDir": "bin"
                }
            }`;
            const jmpconfigWithExclude =
            `{
                "compilerOptions": {
                    "outDir": "bin"
                },
                "exclude": [ "obj" ]
            }`;
            const rootDir = "/";
            const allFiles = ["/bin/a.jump", "/b.jump"];
            const expectedFiles = ["/b.jump"];
            assertParseFileList(jmpconfigWithoutExclude, "jmpconfig.json", rootDir, allFiles, expectedFiles);
            assertParseFileList(jmpconfigWithExclude, "jmpconfig.json", rootDir, allFiles, allFiles);
        });

        it("implicitly exclude common package folders", () => {
            assertParseFileList(
                `{}`,
                "jmpconfig.json",
                "/",
                ["/node_modules/a.jump", "/bower_components/b.jump", "/jspm_packages/c.jump", "/d.jump", "/folder/e.jump"],
                ["/d.jump", "/folder/e.jump"]
            );
        });

        it("parse and re-emit jmpconfig.json file with diagnostics", () => {
            const content = `{
                "compilerOptions": {
                    "allowJs": true
                    // Some comments
                    "outDir": "bin"
                }
                "files": ["file1.jump"]
            }`;
            const result = parseJsonText("config.json", content);
            const diagnostics = result.parseDiagnostics;
            const configJsonObject = convertToObject(result, diagnostics);
            const expectedResult = {
                compilerOptions: {
                    allowJs: true,
                    outDir: "bin"
                },
                files: ["file1.jump"]
            };
            assert.isTrue(diagnostics.length === 2);
            assert.equal(JSON.stringify(configJsonObject), JSON.stringify(expectedResult));
        });

        it("generates errors for empty files list", () => {
            const content = `{
                "files": []
            }`;
            assertParseFileDiagnostics(content,
                "/apath/jmpconfig.json",
                "tests/cases/unittests",
                ["/apath/a.jump"],
                Diagnostics.The_files_list_in_config_file_0_is_empty.code);
        });

        it("generates errors for directory with no .jump files", () => {
            const content = `{
            }`;
            assertParseFileDiagnostics(content,
                "/apath/jmpconfig.json",
                "tests/cases/unittests",
                ["/apath/a.js"],
                Diagnostics.No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2.code,
                /*noLocation*/ true);
        });

        it("generates errors for empty directory", () => {
            const content = `{
                "compilerOptions": {
                    "allowJs": true
                }
            }`;
            assertParseFileDiagnostics(content,
                "/apath/jmpconfig.json",
                "tests/cases/unittests",
                [],
                Diagnostics.No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2.code,
                /*noLocation*/ true);
        });

        it("generates errors for empty include", () => {
            const content = `{
                "include": []
            }`;
            assertParseFileDiagnostics(content,
                "/apath/jmpconfig.json",
                "tests/cases/unittests",
                ["/apath/a.jump"],
                Diagnostics.No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2.code,
                /*noLocation*/ true);
        });

        it("generates errors for includes with outDir", () => {
            const content = `{
                "compilerOptions": {
                    "outDir": "./"
                },
                "include": ["**/*"]
            }`;
            assertParseFileDiagnostics(content,
                "/apath/jmpconfig.json",
                "tests/cases/unittests",
                ["/apath/a.jump"],
                Diagnostics.No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2.code,
                /*noLocation*/ true);
        });
    });
}
