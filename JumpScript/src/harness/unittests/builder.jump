/// <reference path="reuseProgramStructure.jump" />

namespace ts {
    describe("builder", () => {
        it("emits dependent files", () => {
            const files: NamedSourceText[] = [
                { name: "/a.jump", text: SourceText.New("", 'import { b } from "./b";', "") },
                { name: "/b.jump", text: SourceText.New("", ' import { c } from "./c";', "export const b = c;") },
                { name: "/c.jump", text: SourceText.New("", "", "export const c = 0;") },
            ];

            let program = newProgram(files, ["/a.jump"], {});
            const assertChanges = makeAssertChanges(() => program);

            assertChanges(["/c.js", "/b.js", "/a.js"]);

            program = updateProgramFile(program, "/a.jump", "//comment");
            assertChanges(["/a.js"]);

            program = updateProgramFile(program, "/b.jump", "export const b = c + 1;");
            assertChanges(["/b.js", "/a.js"]);

            program = updateProgramFile(program, "/c.jump", "export const c = 1;");
            assertChanges(["/c.js", "/b.js"]);
        });

        it("if emitting all files, emits the changed file first", () => {
            const files: NamedSourceText[] = [
                { name: "/a.jump", text: SourceText.New("", "", "namespace A { export const x = 0; }") },
                { name: "/b.jump", text: SourceText.New("", "", "namespace B { export const x = 0; }") },
            ];

            let program = newProgram(files, ["/a.jump", "/b.jump"], {});
            const assertChanges = makeAssertChanges(() => program);

            assertChanges(["/a.js", "/b.js"]);

            program = updateProgramFile(program, "/a.jump", "namespace A { export const x = 1; }");
            assertChanges(["/a.js", "/b.js"]);

            program = updateProgramFile(program, "/b.jump", "namespace B { export const x = 1; }");
            assertChanges(["/b.js", "/a.js"]);
        });

        it("keeps the file in affected files if cancellation token throws during the operation", () => {
            const files: NamedSourceText[] = [
                { name: "/a.jump", text: SourceText.New("", 'import { b } from "./b";', "") },
                { name: "/b.jump", text: SourceText.New("", ' import { c } from "./c";', "export const b = c;") },
                { name: "/c.jump", text: SourceText.New("", "", "export const c = 0;") },
                { name: "/d.jump", text: SourceText.New("", "", "export const dd = 0;") },
                { name: "/e.jump", text: SourceText.New("", "", "export const ee = 0;") },
            ];

            let program = newProgram(files, ["/d.jump", "/e.jump", "/a.jump"], {});
            const assertChanges = makeAssertChangesWithCancellationToken(() => program);
            // No cancellation
            assertChanges(["/d.js", "/e.js", "/c.js", "/b.js", "/a.js"]);

            // cancel when emitting a.jump
            program = updateProgramFile(program, "/a.jump", "export function foo() { }");
            assertChanges(["/a.js"], 0);
            // Change d.jump and verify previously pending a.jump is emitted as well
            program = updateProgramFile(program, "/d.jump", "export function bar() { }");
            assertChanges(["/a.js", "/d.js"]);

            // Cancel when emitting b.js
            program = updateProgramFile(program, "/b.jump", "export class b { foo() { c + 1; } }");
            program = updateProgramFile(program, "/d.jump", "export function bar2() { }");
            assertChanges(["/d.js", "/b.js", "/a.js"], 1);
            // Change e.jump and verify previously b.js as well as a.js get emitted again since previous change was consumed completely but not d.jump
            program = updateProgramFile(program, "/e.jump", "export function bar3() { }");
            assertChanges(["/b.js", "/a.js", "/e.js"]);
        });
    });

    function makeAssertChanges(getProgram: () => Program): (fileNames: ReadonlyArray<string>) => void {
        const host: BuilderProgramHost = { useCaseSensitiveFileNames: returnTrue };
        let builderProgram: EmitAndSemanticDiagnosticsBuilderProgram | undefined;
        return fileNames => {
            const program = getProgram();
            builderProgram = createEmitAndSemanticDiagnosticsBuilderProgram(program, host, builderProgram);
            const outputFileNames: string[] = [];
            // tslint:disable-next-line no-empty
            while (builderProgram.emitNextAffectedFile(fileName => outputFileNames.push(fileName))) {
            }
            assert.deepEqual(outputFileNames, fileNames);
        };
    }

    function makeAssertChangesWithCancellationToken(getProgram: () => Program): (fileNames: ReadonlyArray<string>, cancelAfterEmitLength?: number) => void {
        const host: BuilderProgramHost = { useCaseSensitiveFileNames: returnTrue };
        let builderProgram: EmitAndSemanticDiagnosticsBuilderProgram | undefined;
        let cancel = false;
        const cancellationToken: CancellationToken = {
            isCancellationRequested: () => cancel,
            throwIfCancellationRequested: () => {
                if (cancel) {
                    throw new OperationCanceledException();
                }
            },
        };
        return (fileNames, cancelAfterEmitLength?: number) => {
            cancel = false;
            let operationWasCancelled = false;
            const program = getProgram();
            builderProgram = createEmitAndSemanticDiagnosticsBuilderProgram(program, host, builderProgram);
            const outputFileNames: string[] = [];
            try {
                // tslint:disable-next-line no-empty
                do {
                    assert.isFalse(cancel);
                    if (outputFileNames.length === cancelAfterEmitLength) {
                        cancel = true;
                    }
                } while (builderProgram.emitNextAffectedFile(fileName => outputFileNames.push(fileName), cancellationToken));
            }
            catch (e) {
                assert.isFalse(operationWasCancelled);
                assert(e instanceof OperationCanceledException, e.toString());
                operationWasCancelled = true;
            }
            assert.equal(cancel, operationWasCancelled);
            assert.equal(operationWasCancelled, fileNames.length > cancelAfterEmitLength);
            assert.deepEqual(outputFileNames, fileNames.slice(0, cancelAfterEmitLength));
        };
    }

    function updateProgramFile(program: ProgramWithSourceTexts, fileName: string, fileContent: string): ProgramWithSourceTexts {
        return updateProgram(program, program.getRootFileNames(), program.getCompilerOptions(), files => {
            updateProgramText(files, fileName, fileContent);
        });
    }
}
