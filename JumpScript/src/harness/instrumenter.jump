import fs = require("fs");
import path = require("path");

function instrumentForRecording(fn: string, jmpcPath: string) {
    instrument(jmpcPath, `
ts.sys = Playback.wrapSystem(ts.sys);
ts.sys.startRecord("${ fn }");`, `ts.sys.endRecord();`);
}

function instrumentForReplay(logFilename: string, jmpcPath: string) {
    instrument(jmpcPath, `
ts.sys = Playback.wrapSystem(ts.sys);
ts.sys.startReplay("${ logFilename }");`);
}

function instrument(jmpcPath: string, prepareCode: string, cleanupCode = "") {
    const bak = `${jmpcPath}.bak`;
    fs.exists(bak, (backupExists: boolean) => {
        let filename = jmpcPath;
        if (backupExists) {
            filename = bak;
        }

        fs.readFile(filename, "utf-8", (err: any, jmpcContent: string) => {
            if (err) throw err;

            fs.writeFile(bak, jmpcContent, (err: any) => {
                if (err) throw err;

                fs.readFile(path.resolve(path.dirname(jmpcPath) + "/loggedIO.js"), "utf-8", (err: any, loggerContent: string) => {
                    if (err) throw err;

                    const invocationLine = "ts.executeCommandLine(ts.sys.args);";
                    const index1 = jmpcContent.indexOf(invocationLine);
                    if (index1 < 0) {
                        throw new Error(`Could not find ${invocationLine}`);
                    }

                    const index2 = index1 + invocationLine.length;
                    const newContent = jmpcContent.substr(0, index1) + loggerContent + prepareCode + invocationLine + cleanupCode + jmpcContent.substr(index2) + "\r\n";
                    fs.writeFile(jmpcPath, newContent, err => {
                        if (err) throw err;
                    });
                });
            });
        });
    });
}

const isJson = (arg: string) => arg.indexOf(".json") > 0;

const record = process.argv.indexOf("record");
const jmpcPath = process.argv[process.argv.length - 1];
if (record >= 0) {
    console.log(`Instrumenting ${jmpcPath} for recording`);
    instrumentForRecording(process.argv[record + 1], jmpcPath);
}
else if (process.argv.some(isJson)) {
    const filename = process.argv.filter(isJson)[0];
    instrumentForReplay(filename, jmpcPath);
}


