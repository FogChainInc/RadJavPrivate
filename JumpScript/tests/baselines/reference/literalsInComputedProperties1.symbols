=== tests/cases/compiler/literalsInComputedProperties1.jump ===
let x = {
>x : Symbol(x, Decl(literalsInComputedProperties1.jump, 0, 3))

    1:1,
    [2]:1,
>2 : Symbol([2], Decl(literalsInComputedProperties1.jump, 1, 8))

    "3":1,
    ["4"]:1
>"4" : Symbol(["4"], Decl(literalsInComputedProperties1.jump, 3, 10))
}
x[1].toExponential();
>x[1].toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))
>x : Symbol(x, Decl(literalsInComputedProperties1.jump, 0, 3))
>1 : Symbol(1, Decl(literalsInComputedProperties1.jump, 0, 9))
>toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))

x[2].toExponential();
>x[2].toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))
>x : Symbol(x, Decl(literalsInComputedProperties1.jump, 0, 3))
>2 : Symbol([2], Decl(literalsInComputedProperties1.jump, 1, 8))
>toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))

x[3].toExponential();
>x[3].toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))
>x : Symbol(x, Decl(literalsInComputedProperties1.jump, 0, 3))
>3 : Symbol("3", Decl(literalsInComputedProperties1.jump, 2, 10))
>toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))

x[4].toExponential();
>x[4].toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))
>x : Symbol(x, Decl(literalsInComputedProperties1.jump, 0, 3))
>4 : Symbol(["4"], Decl(literalsInComputedProperties1.jump, 3, 10))
>toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))

interface A {
>A : Symbol(A, Decl(literalsInComputedProperties1.jump, 9, 21))

    1:number;
    [2]:number;
>2 : Symbol(A[2], Decl(literalsInComputedProperties1.jump, 12, 13))

    "3":number;
    ["4"]:number;
>"4" : Symbol(A["4"], Decl(literalsInComputedProperties1.jump, 14, 15))
}

let y:A;
>y : Symbol(y, Decl(literalsInComputedProperties1.jump, 18, 3))
>A : Symbol(A, Decl(literalsInComputedProperties1.jump, 9, 21))

y[1].toExponential();
>y[1].toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))
>y : Symbol(y, Decl(literalsInComputedProperties1.jump, 18, 3))
>1 : Symbol(A[1], Decl(literalsInComputedProperties1.jump, 11, 13))
>toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))

y[2].toExponential();
>y[2].toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))
>y : Symbol(y, Decl(literalsInComputedProperties1.jump, 18, 3))
>2 : Symbol(A[2], Decl(literalsInComputedProperties1.jump, 12, 13))
>toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))

y[3].toExponential();
>y[3].toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))
>y : Symbol(y, Decl(literalsInComputedProperties1.jump, 18, 3))
>3 : Symbol(A["3"], Decl(literalsInComputedProperties1.jump, 13, 15))
>toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))

y[4].toExponential();
>y[4].toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))
>y : Symbol(y, Decl(literalsInComputedProperties1.jump, 18, 3))
>4 : Symbol(A["4"], Decl(literalsInComputedProperties1.jump, 14, 15))
>toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))

class C {
>C : Symbol(C, Decl(literalsInComputedProperties1.jump, 22, 21))

    1:number;
    [2]:number;
>2 : Symbol(C[2], Decl(literalsInComputedProperties1.jump, 25, 13))

    "3":number;
    ["4"]:number;
>"4" : Symbol(C["4"], Decl(literalsInComputedProperties1.jump, 27, 15))
}

let z:C;
>z : Symbol(z, Decl(literalsInComputedProperties1.jump, 31, 3))
>C : Symbol(C, Decl(literalsInComputedProperties1.jump, 22, 21))

z[1].toExponential();
>z[1].toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))
>z : Symbol(z, Decl(literalsInComputedProperties1.jump, 31, 3))
>1 : Symbol(C[1], Decl(literalsInComputedProperties1.jump, 24, 9))
>toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))

z[2].toExponential();
>z[2].toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))
>z : Symbol(z, Decl(literalsInComputedProperties1.jump, 31, 3))
>2 : Symbol(C[2], Decl(literalsInComputedProperties1.jump, 25, 13))
>toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))

z[3].toExponential();
>z[3].toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))
>z : Symbol(z, Decl(literalsInComputedProperties1.jump, 31, 3))
>3 : Symbol(C["3"], Decl(literalsInComputedProperties1.jump, 26, 15))
>toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))

z[4].toExponential();
>z[4].toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))
>z : Symbol(z, Decl(literalsInComputedProperties1.jump, 31, 3))
>4 : Symbol(C["4"], Decl(literalsInComputedProperties1.jump, 27, 15))
>toExponential : Symbol(Number.toExponential, Decl(lib.d.jump, --, --))

enum X {
>X : Symbol(X, Decl(literalsInComputedProperties1.jump, 35, 21))

    1 = 1,
    [2] = 2,
>2 : Symbol(X[2], Decl(literalsInComputedProperties1.jump, 38, 10))

    "3" = 3,
    ["4"] = 4,
>"4" : Symbol(X["4"], Decl(literalsInComputedProperties1.jump, 40, 12))

    "foo" = 5,
    ["bar"] = 6
>"bar" : Symbol(X["bar"], Decl(literalsInComputedProperties1.jump, 42, 14))
}

let a = X["foo"];
>a : Symbol(a, Decl(literalsInComputedProperties1.jump, 46, 3))
>X : Symbol(X, Decl(literalsInComputedProperties1.jump, 35, 21))
>"foo" : Symbol(X["foo"], Decl(literalsInComputedProperties1.jump, 41, 14))

let a0 = X["bar"];
>a0 : Symbol(a0, Decl(literalsInComputedProperties1.jump, 47, 3))
>X : Symbol(X, Decl(literalsInComputedProperties1.jump, 35, 21))
>"bar" : Symbol(X["bar"], Decl(literalsInComputedProperties1.jump, 42, 14))

// TODO: make sure that enum still disallow template literals as member names
