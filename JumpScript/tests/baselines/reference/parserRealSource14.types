=== tests/cases/conformance/parser/ecmascript5/parserRealSource14.jump ===
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='jumpscript.jump' />

module JumpScript {
>JumpScript : typeof JumpScript

    export function lastOf(items: any[]): any {
>lastOf : (items: any[]) => any
>items : any[]

        return (items === null || items.length === 0) ? null : items[items.length - 1];
>(items === null || items.length === 0) ? null : items[items.length - 1] : any
>(items === null || items.length === 0) : boolean
>items === null || items.length === 0 : boolean
>items === null : boolean
>items : any[]
>null : null
>items.length === 0 : boolean
>items.length : number
>items : any[]
>length : number
>0 : 0
>null : null
>items[items.length - 1] : any
>items : any[]
>items.length - 1 : number
>items.length : number
>items : any[]
>length : number
>1 : 1
    }

    export function max(a: number, b: number): number {
>max : (a: number, b: number) => number
>a : number
>b : number

        return a >= b ? a : b;
>a >= b ? a : b : number
>a >= b : boolean
>a : number
>b : number
>a : number
>b : number
    }

    export function min(a: number, b: number): number {
>min : (a: number, b: number) => number
>a : number
>b : number

        return a <= b ? a : b;
>a <= b ? a : b : number
>a <= b : boolean
>a : number
>b : number
>a : number
>b : number
    }

    //
    // Helper class representing a path from a root ast node to a (grand)child ast node.
    // This is helpful as our tree don't have parents.
    //
    export class AstPath {
>AstPath : AstPath

        public asts: JumpScript.AST[] = [];
>asts : any[]
>JumpScript : any
>AST : No type information available!
>[] : undefined[]

        public top: number = -1;
>top : number
>-1 : -1
>1 : 1

        static reverseIndexOf(items: any[], index: number): any {
>reverseIndexOf : (items: any[], index: number) => any
>items : any[]
>index : number

            return (items === null || items.length <= index) ? null : items[items.length - index - 1];
>(items === null || items.length <= index) ? null : items[items.length - index - 1] : any
>(items === null || items.length <= index) : boolean
>items === null || items.length <= index : boolean
>items === null : boolean
>items : any[]
>null : null
>items.length <= index : boolean
>items.length : number
>items : any[]
>length : number
>index : number
>null : null
>items[items.length - index - 1] : any
>items : any[]
>items.length - index - 1 : number
>items.length - index : number
>items.length : number
>items : any[]
>length : number
>index : number
>1 : 1
        }

        public clone(): AstPath {
>clone : () => AstPath
>AstPath : AstPath

            var clone = new AstPath();
>clone : AstPath
>new AstPath() : AstPath
>AstPath : typeof AstPath

            clone.asts = this.asts.map((value) => { return value; });
>clone.asts = this.asts.map((value) => { return value; }) : any[]
>clone.asts : any[]
>clone : AstPath
>asts : any[]
>this.asts.map((value) => { return value; }) : any[]
>this.asts.map : <U>(callbackfn: (value: any, index: number, array: any[]) => U, thisArg?: any) => U[]
>this.asts : any[]
>this : this
>asts : any[]
>map : <U>(callbackfn: (value: any, index: number, array: any[]) => U, thisArg?: any) => U[]
>(value) => { return value; } : (value: any) => any
>value : any
>value : any

            clone.top = this.top;
>clone.top = this.top : number
>clone.top : number
>clone : AstPath
>top : number
>this.top : number
>this : this
>top : number

            return clone;
>clone : AstPath
        }

        public pop(): JumpScript.AST {
>pop : () => any
>JumpScript : any
>AST : No type information available!

            var head = this.ast();
>head : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any

            this.up();
>this.up() : void
>this.up : () => void
>this : this
>up : () => void

            while (this.asts.length > this.count()) {
>this.asts.length > this.count() : boolean
>this.asts.length : number
>this.asts : any[]
>this : this
>asts : any[]
>length : number
>this.count() : number
>this.count : () => number
>this : this
>count : () => number

                this.asts.pop();
>this.asts.pop() : any
>this.asts.pop : () => any
>this.asts : any[]
>this : this
>asts : any[]
>pop : () => any
            }
            return head;
>head : any
        }

        public push(ast: JumpScript.AST) {
>push : (ast: any) => void
>ast : any
>JumpScript : any
>AST : No type information available!

            while (this.asts.length > this.count()) {
>this.asts.length > this.count() : boolean
>this.asts.length : number
>this.asts : any[]
>this : this
>asts : any[]
>length : number
>this.count() : number
>this.count : () => number
>this : this
>count : () => number

                this.asts.pop();
>this.asts.pop() : any
>this.asts.pop : () => any
>this.asts : any[]
>this : this
>asts : any[]
>pop : () => any
            }
            this.top = this.asts.length;
>this.top = this.asts.length : number
>this.top : number
>this : this
>top : number
>this.asts.length : number
>this.asts : any[]
>this : this
>asts : any[]
>length : number

            this.asts.push(ast);
>this.asts.push(ast) : number
>this.asts.push : (...items: any[]) => number
>this.asts : any[]
>this : this
>asts : any[]
>push : (...items: any[]) => number
>ast : any
        }

        public up() {
>up : () => void

            if (this.top <= -1)
>this.top <= -1 : boolean
>this.top : number
>this : this
>top : number
>-1 : -1
>1 : 1

                throw new Error("Invalid call to 'up'");
>new Error("Invalid call to 'up'") : Error
>Error : ErrorConstructor
>"Invalid call to 'up'" : "Invalid call to 'up'"

            this.top--;
>this.top-- : number
>this.top : number
>this : this
>top : number
        }

        public down() {
>down : () => void

            if (this.top == this.ast.length - 1)
>this.top == this.ast.length - 1 : boolean
>this.top : number
>this : this
>top : number
>this.ast.length - 1 : number
>this.ast.length : number
>this.ast : () => any
>this : this
>ast : () => any
>length : number
>1 : 1

                throw new Error("Invalid call to 'down'");
>new Error("Invalid call to 'down'") : Error
>Error : ErrorConstructor
>"Invalid call to 'down'" : "Invalid call to 'down'"

            this.top++;
>this.top++ : number
>this.top : number
>this : this
>top : number
        }

        public nodeType(): JumpScript.NodeType {
>nodeType : () => any
>JumpScript : any
>NodeType : No type information available!

            if (this.ast() == null)
>this.ast() == null : boolean
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>null : null

                return JumpScript.NodeType.None;
>JumpScript.NodeType.None : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>None : any

            return this.ast().nodeType;
>this.ast().nodeType : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>nodeType : any
        }

        public ast() {
>ast : () => any

            return <JumpScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1));
><JumpScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1)) : any
>JumpScript : any
>AST : No type information available!
>AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1)) : any
>AstPath.reverseIndexOf : (items: any[], index: number) => any
>AstPath : typeof AstPath
>reverseIndexOf : (items: any[], index: number) => any
>this.asts : any[]
>this : this
>asts : any[]
>this.asts.length - (this.top + 1) : number
>this.asts.length : number
>this.asts : any[]
>this : this
>asts : any[]
>length : number
>(this.top + 1) : number
>this.top + 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
        }

        public parent() {
>parent : () => any

            return <JumpScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - this.top);
><JumpScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - this.top) : any
>JumpScript : any
>AST : No type information available!
>AstPath.reverseIndexOf(this.asts, this.asts.length - this.top) : any
>AstPath.reverseIndexOf : (items: any[], index: number) => any
>AstPath : typeof AstPath
>reverseIndexOf : (items: any[], index: number) => any
>this.asts : any[]
>this : this
>asts : any[]
>this.asts.length - this.top : number
>this.asts.length : number
>this.asts : any[]
>this : this
>asts : any[]
>length : number
>this.top : number
>this : this
>top : number
        }

        public count() {
>count : () => number

            return this.top + 1;
>this.top + 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
        }

        public get(index: number): JumpScript.AST {
>get : (index: number) => any
>index : number
>JumpScript : any
>AST : No type information available!

            return this.asts[index];
>this.asts[index] : any
>this.asts : any[]
>this : this
>asts : any[]
>index : number
        }

        public isNameOfClass(): boolean {
>isNameOfClass : () => boolean

            if (this.ast() === null || this.parent() === null)
>this.ast() === null || this.parent() === null : boolean
>this.ast() === null : boolean
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>null : null
>this.parent() === null : boolean
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>null : null

                return false;
>false : false

            return (this.ast().nodeType === JumpScript.NodeType.Name) &&
>(this.ast().nodeType === JumpScript.NodeType.Name) &&                (this.parent().nodeType === JumpScript.NodeType.ClassDeclaration) &&                ((<JumpScript.InterfaceDeclaration>this.parent()).name === this.ast()) : boolean
>(this.ast().nodeType === JumpScript.NodeType.Name) &&                (this.parent().nodeType === JumpScript.NodeType.ClassDeclaration) : boolean
>(this.ast().nodeType === JumpScript.NodeType.Name) : boolean
>this.ast().nodeType === JumpScript.NodeType.Name : boolean
>this.ast().nodeType : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>nodeType : any
>JumpScript.NodeType.Name : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Name : any

                (this.parent().nodeType === JumpScript.NodeType.ClassDeclaration) &&
>(this.parent().nodeType === JumpScript.NodeType.ClassDeclaration) : boolean
>this.parent().nodeType === JumpScript.NodeType.ClassDeclaration : boolean
>this.parent().nodeType : any
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>nodeType : any
>JumpScript.NodeType.ClassDeclaration : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ClassDeclaration : any

                ((<JumpScript.InterfaceDeclaration>this.parent()).name === this.ast());
>((<JumpScript.InterfaceDeclaration>this.parent()).name === this.ast()) : boolean
>(<JumpScript.InterfaceDeclaration>this.parent()).name === this.ast() : boolean
>(<JumpScript.InterfaceDeclaration>this.parent()).name : any
>(<JumpScript.InterfaceDeclaration>this.parent()) : any
><JumpScript.InterfaceDeclaration>this.parent() : any
>JumpScript : any
>InterfaceDeclaration : No type information available!
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>name : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
        }

        public isNameOfInterface(): boolean {
>isNameOfInterface : () => boolean

            if (this.ast() === null || this.parent() === null)
>this.ast() === null || this.parent() === null : boolean
>this.ast() === null : boolean
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>null : null
>this.parent() === null : boolean
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>null : null

                return false;
>false : false

            return (this.ast().nodeType === JumpScript.NodeType.Name) &&
>(this.ast().nodeType === JumpScript.NodeType.Name) &&                (this.parent().nodeType === JumpScript.NodeType.InterfaceDeclaration) &&                ((<JumpScript.InterfaceDeclaration>this.parent()).name === this.ast()) : boolean
>(this.ast().nodeType === JumpScript.NodeType.Name) &&                (this.parent().nodeType === JumpScript.NodeType.InterfaceDeclaration) : boolean
>(this.ast().nodeType === JumpScript.NodeType.Name) : boolean
>this.ast().nodeType === JumpScript.NodeType.Name : boolean
>this.ast().nodeType : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>nodeType : any
>JumpScript.NodeType.Name : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Name : any

                (this.parent().nodeType === JumpScript.NodeType.InterfaceDeclaration) &&
>(this.parent().nodeType === JumpScript.NodeType.InterfaceDeclaration) : boolean
>this.parent().nodeType === JumpScript.NodeType.InterfaceDeclaration : boolean
>this.parent().nodeType : any
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>nodeType : any
>JumpScript.NodeType.InterfaceDeclaration : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>InterfaceDeclaration : any

                ((<JumpScript.InterfaceDeclaration>this.parent()).name === this.ast());
>((<JumpScript.InterfaceDeclaration>this.parent()).name === this.ast()) : boolean
>(<JumpScript.InterfaceDeclaration>this.parent()).name === this.ast() : boolean
>(<JumpScript.InterfaceDeclaration>this.parent()).name : any
>(<JumpScript.InterfaceDeclaration>this.parent()) : any
><JumpScript.InterfaceDeclaration>this.parent() : any
>JumpScript : any
>InterfaceDeclaration : No type information available!
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>name : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
        }

        public isNameOfArgument(): boolean {
>isNameOfArgument : () => boolean

            if (this.ast() === null || this.parent() === null)
>this.ast() === null || this.parent() === null : boolean
>this.ast() === null : boolean
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>null : null
>this.parent() === null : boolean
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>null : null

                return false;
>false : false

            return (this.ast().nodeType === JumpScript.NodeType.Name) &&
>(this.ast().nodeType === JumpScript.NodeType.Name) &&                (this.parent().nodeType === JumpScript.NodeType.ArgDecl) &&                ((<JumpScript.ArgDecl>this.parent()).id === this.ast()) : boolean
>(this.ast().nodeType === JumpScript.NodeType.Name) &&                (this.parent().nodeType === JumpScript.NodeType.ArgDecl) : boolean
>(this.ast().nodeType === JumpScript.NodeType.Name) : boolean
>this.ast().nodeType === JumpScript.NodeType.Name : boolean
>this.ast().nodeType : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>nodeType : any
>JumpScript.NodeType.Name : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Name : any

                (this.parent().nodeType === JumpScript.NodeType.ArgDecl) &&
>(this.parent().nodeType === JumpScript.NodeType.ArgDecl) : boolean
>this.parent().nodeType === JumpScript.NodeType.ArgDecl : boolean
>this.parent().nodeType : any
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>nodeType : any
>JumpScript.NodeType.ArgDecl : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ArgDecl : any

                ((<JumpScript.ArgDecl>this.parent()).id === this.ast());
>((<JumpScript.ArgDecl>this.parent()).id === this.ast()) : boolean
>(<JumpScript.ArgDecl>this.parent()).id === this.ast() : boolean
>(<JumpScript.ArgDecl>this.parent()).id : any
>(<JumpScript.ArgDecl>this.parent()) : any
><JumpScript.ArgDecl>this.parent() : any
>JumpScript : any
>ArgDecl : No type information available!
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>id : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
        }

        public isNameOfVariable(): boolean {
>isNameOfVariable : () => boolean

            if (this.ast() === null || this.parent() === null)
>this.ast() === null || this.parent() === null : boolean
>this.ast() === null : boolean
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>null : null
>this.parent() === null : boolean
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>null : null

                return false;
>false : false

            return (this.ast().nodeType === JumpScript.NodeType.Name) &&
>(this.ast().nodeType === JumpScript.NodeType.Name) &&                (this.parent().nodeType === JumpScript.NodeType.VarDecl) &&                ((<JumpScript.VarDecl>this.parent()).id === this.ast()) : boolean
>(this.ast().nodeType === JumpScript.NodeType.Name) &&                (this.parent().nodeType === JumpScript.NodeType.VarDecl) : boolean
>(this.ast().nodeType === JumpScript.NodeType.Name) : boolean
>this.ast().nodeType === JumpScript.NodeType.Name : boolean
>this.ast().nodeType : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>nodeType : any
>JumpScript.NodeType.Name : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Name : any

                (this.parent().nodeType === JumpScript.NodeType.VarDecl) &&
>(this.parent().nodeType === JumpScript.NodeType.VarDecl) : boolean
>this.parent().nodeType === JumpScript.NodeType.VarDecl : boolean
>this.parent().nodeType : any
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>nodeType : any
>JumpScript.NodeType.VarDecl : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>VarDecl : any

                ((<JumpScript.VarDecl>this.parent()).id === this.ast());
>((<JumpScript.VarDecl>this.parent()).id === this.ast()) : boolean
>(<JumpScript.VarDecl>this.parent()).id === this.ast() : boolean
>(<JumpScript.VarDecl>this.parent()).id : any
>(<JumpScript.VarDecl>this.parent()) : any
><JumpScript.VarDecl>this.parent() : any
>JumpScript : any
>VarDecl : No type information available!
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>id : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
        }

        public isNameOfModule(): boolean {
>isNameOfModule : () => boolean

            if (this.ast() === null || this.parent() === null)
>this.ast() === null || this.parent() === null : boolean
>this.ast() === null : boolean
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>null : null
>this.parent() === null : boolean
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>null : null

                return false;
>false : false

            return (this.ast().nodeType === JumpScript.NodeType.Name) &&
>(this.ast().nodeType === JumpScript.NodeType.Name) &&                (this.parent().nodeType === JumpScript.NodeType.ModuleDeclaration) &&                ((<JumpScript.ModuleDeclaration>this.parent()).name === this.ast()) : boolean
>(this.ast().nodeType === JumpScript.NodeType.Name) &&                (this.parent().nodeType === JumpScript.NodeType.ModuleDeclaration) : boolean
>(this.ast().nodeType === JumpScript.NodeType.Name) : boolean
>this.ast().nodeType === JumpScript.NodeType.Name : boolean
>this.ast().nodeType : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>nodeType : any
>JumpScript.NodeType.Name : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Name : any

                (this.parent().nodeType === JumpScript.NodeType.ModuleDeclaration) &&
>(this.parent().nodeType === JumpScript.NodeType.ModuleDeclaration) : boolean
>this.parent().nodeType === JumpScript.NodeType.ModuleDeclaration : boolean
>this.parent().nodeType : any
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>nodeType : any
>JumpScript.NodeType.ModuleDeclaration : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ModuleDeclaration : any

                ((<JumpScript.ModuleDeclaration>this.parent()).name === this.ast());
>((<JumpScript.ModuleDeclaration>this.parent()).name === this.ast()) : boolean
>(<JumpScript.ModuleDeclaration>this.parent()).name === this.ast() : boolean
>(<JumpScript.ModuleDeclaration>this.parent()).name : any
>(<JumpScript.ModuleDeclaration>this.parent()) : any
><JumpScript.ModuleDeclaration>this.parent() : any
>JumpScript : any
>ModuleDeclaration : No type information available!
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>name : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
        }

        public isNameOfFunction(): boolean {
>isNameOfFunction : () => boolean

            if (this.ast() === null || this.parent() === null)
>this.ast() === null || this.parent() === null : boolean
>this.ast() === null : boolean
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>null : null
>this.parent() === null : boolean
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>null : null

                return false;
>false : false

            return (this.ast().nodeType === JumpScript.NodeType.Name) &&
>(this.ast().nodeType === JumpScript.NodeType.Name) &&                (this.parent().nodeType === JumpScript.NodeType.FuncDecl) &&                ((<JumpScript.FuncDecl>this.parent()).name === this.ast()) : boolean
>(this.ast().nodeType === JumpScript.NodeType.Name) &&                (this.parent().nodeType === JumpScript.NodeType.FuncDecl) : boolean
>(this.ast().nodeType === JumpScript.NodeType.Name) : boolean
>this.ast().nodeType === JumpScript.NodeType.Name : boolean
>this.ast().nodeType : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
>nodeType : any
>JumpScript.NodeType.Name : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Name : any

                (this.parent().nodeType === JumpScript.NodeType.FuncDecl) &&
>(this.parent().nodeType === JumpScript.NodeType.FuncDecl) : boolean
>this.parent().nodeType === JumpScript.NodeType.FuncDecl : boolean
>this.parent().nodeType : any
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>nodeType : any
>JumpScript.NodeType.FuncDecl : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>FuncDecl : any

                ((<JumpScript.FuncDecl>this.parent()).name === this.ast());
>((<JumpScript.FuncDecl>this.parent()).name === this.ast()) : boolean
>(<JumpScript.FuncDecl>this.parent()).name === this.ast() : boolean
>(<JumpScript.FuncDecl>this.parent()).name : any
>(<JumpScript.FuncDecl>this.parent()) : any
><JumpScript.FuncDecl>this.parent() : any
>JumpScript : any
>FuncDecl : No type information available!
>this.parent() : any
>this.parent : () => any
>this : this
>parent : () => any
>name : any
>this.ast() : any
>this.ast : () => any
>this : this
>ast : () => any
        }

        public isChildOfScript(): boolean {
>isChildOfScript : () => boolean

            var ast = lastOf(this.asts);
>ast : any
>lastOf(this.asts) : any
>lastOf : (items: any[]) => any
>this.asts : any[]
>this : this
>asts : any[]

            return this.count() >= 3 &&
>this.count() >= 3 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.Script : boolean
>this.count() >= 3 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 3 &&                this.asts[this.top] === ast : boolean
>this.count() >= 3 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>3 : 3

                this.asts[this.top] === ast &&
>this.asts[this.top] === ast : boolean
>this.asts[this.top] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top : number
>this : this
>top : number
>ast : any

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                this.asts[this.top - 2].nodeType === JumpScript.NodeType.Script;
>this.asts[this.top - 2].nodeType === JumpScript.NodeType.Script : boolean
>this.asts[this.top - 2].nodeType : any
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>nodeType : any
>JumpScript.NodeType.Script : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Script : any
        }

        public isChildOfModule(): boolean {
>isChildOfModule : () => boolean

            var ast = lastOf(this.asts);
>ast : any
>lastOf(this.asts) : any
>lastOf : (items: any[]) => any
>this.asts : any[]
>this : this
>asts : any[]

            return this.count() >= 3 &&
>this.count() >= 3 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.ModuleDeclaration : boolean
>this.count() >= 3 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 3 &&                this.asts[this.top] === ast : boolean
>this.count() >= 3 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>3 : 3

                this.asts[this.top] === ast &&
>this.asts[this.top] === ast : boolean
>this.asts[this.top] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top : number
>this : this
>top : number
>ast : any

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                this.asts[this.top - 2].nodeType === JumpScript.NodeType.ModuleDeclaration;
>this.asts[this.top - 2].nodeType === JumpScript.NodeType.ModuleDeclaration : boolean
>this.asts[this.top - 2].nodeType : any
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>nodeType : any
>JumpScript.NodeType.ModuleDeclaration : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ModuleDeclaration : any
        }

        public isChildOfClass(): boolean {
>isChildOfClass : () => boolean

            var ast = lastOf(this.asts);
>ast : any
>lastOf(this.asts) : any
>lastOf : (items: any[]) => any
>this.asts : any[]
>this : this
>asts : any[]

            return this.count() >= 3 &&
>this.count() >= 3 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.ClassDeclaration : boolean
>this.count() >= 3 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 3 &&                this.asts[this.top] === ast : boolean
>this.count() >= 3 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>3 : 3

                this.asts[this.top] === ast &&
>this.asts[this.top] === ast : boolean
>this.asts[this.top] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top : number
>this : this
>top : number
>ast : any

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                this.asts[this.top - 2].nodeType === JumpScript.NodeType.ClassDeclaration;
>this.asts[this.top - 2].nodeType === JumpScript.NodeType.ClassDeclaration : boolean
>this.asts[this.top - 2].nodeType : any
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>nodeType : any
>JumpScript.NodeType.ClassDeclaration : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ClassDeclaration : any
        }

        public isArgumentOfClassConstructor(): boolean {
>isArgumentOfClassConstructor : () => boolean

            var ast = lastOf(this.asts);
>ast : any
>lastOf(this.asts) : any
>lastOf : (items: any[]) => any
>this.asts : any[]
>this : this
>asts : any[]

            return this.count() >= 5 &&
>this.count() >= 5 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.FuncDecl &&                this.asts[this.top - 3].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 4].nodeType === JumpScript.NodeType.ClassDeclaration &&                ((<JumpScript.FuncDecl>this.asts[this.top - 2]).isConstructor) &&                ((<JumpScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1]) &&                ((<JumpScript.ClassDeclaration>this.asts[this.top - 4]).constructorDecl === this.asts[this.top - 2]) : boolean
>this.count() >= 5 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.FuncDecl &&                this.asts[this.top - 3].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 4].nodeType === JumpScript.NodeType.ClassDeclaration &&                ((<JumpScript.FuncDecl>this.asts[this.top - 2]).isConstructor) &&                ((<JumpScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1]) : boolean
>this.count() >= 5 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.FuncDecl &&                this.asts[this.top - 3].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 4].nodeType === JumpScript.NodeType.ClassDeclaration &&                ((<JumpScript.FuncDecl>this.asts[this.top - 2]).isConstructor) : any
>this.count() >= 5 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.FuncDecl &&                this.asts[this.top - 3].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 4].nodeType === JumpScript.NodeType.ClassDeclaration : boolean
>this.count() >= 5 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.FuncDecl &&                this.asts[this.top - 3].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 5 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.FuncDecl : boolean
>this.count() >= 5 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 5 &&                this.asts[this.top] === ast : boolean
>this.count() >= 5 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>5 : 5

                this.asts[this.top] === ast &&
>this.asts[this.top] === ast : boolean
>this.asts[this.top] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top : number
>this : this
>top : number
>ast : any

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                this.asts[this.top - 2].nodeType === JumpScript.NodeType.FuncDecl &&
>this.asts[this.top - 2].nodeType === JumpScript.NodeType.FuncDecl : boolean
>this.asts[this.top - 2].nodeType : any
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>nodeType : any
>JumpScript.NodeType.FuncDecl : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>FuncDecl : any

                this.asts[this.top - 3].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 3].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 3].nodeType : any
>this.asts[this.top - 3] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 3 : number
>this.top : number
>this : this
>top : number
>3 : 3
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                this.asts[this.top - 4].nodeType === JumpScript.NodeType.ClassDeclaration &&
>this.asts[this.top - 4].nodeType === JumpScript.NodeType.ClassDeclaration : boolean
>this.asts[this.top - 4].nodeType : any
>this.asts[this.top - 4] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 4 : number
>this.top : number
>this : this
>top : number
>4 : 4
>nodeType : any
>JumpScript.NodeType.ClassDeclaration : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ClassDeclaration : any

                ((<JumpScript.FuncDecl>this.asts[this.top - 2]).isConstructor) &&
>((<JumpScript.FuncDecl>this.asts[this.top - 2]).isConstructor) : any
>(<JumpScript.FuncDecl>this.asts[this.top - 2]).isConstructor : any
>(<JumpScript.FuncDecl>this.asts[this.top - 2]) : any
><JumpScript.FuncDecl>this.asts[this.top - 2] : any
>JumpScript : any
>FuncDecl : No type information available!
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>isConstructor : any

                ((<JumpScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1]) &&
>((<JumpScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1]) : boolean
>(<JumpScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1] : boolean
>(<JumpScript.FuncDecl>this.asts[this.top - 2]).arguments : any
>(<JumpScript.FuncDecl>this.asts[this.top - 2]) : any
><JumpScript.FuncDecl>this.asts[this.top - 2] : any
>JumpScript : any
>FuncDecl : No type information available!
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>arguments : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1

                ((<JumpScript.ClassDeclaration>this.asts[this.top - 4]).constructorDecl === this.asts[this.top - 2]);
>((<JumpScript.ClassDeclaration>this.asts[this.top - 4]).constructorDecl === this.asts[this.top - 2]) : boolean
>(<JumpScript.ClassDeclaration>this.asts[this.top - 4]).constructorDecl === this.asts[this.top - 2] : boolean
>(<JumpScript.ClassDeclaration>this.asts[this.top - 4]).constructorDecl : any
>(<JumpScript.ClassDeclaration>this.asts[this.top - 4]) : any
><JumpScript.ClassDeclaration>this.asts[this.top - 4] : any
>JumpScript : any
>ClassDeclaration : No type information available!
>this.asts[this.top - 4] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 4 : number
>this.top : number
>this : this
>top : number
>4 : 4
>constructorDecl : any
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
        }

        public isChildOfInterface(): boolean {
>isChildOfInterface : () => boolean

            var ast = lastOf(this.asts);
>ast : any
>lastOf(this.asts) : any
>lastOf : (items: any[]) => any
>this.asts : any[]
>this : this
>asts : any[]

            return this.count() >= 3 &&
>this.count() >= 3 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.InterfaceDeclaration : boolean
>this.count() >= 3 &&                this.asts[this.top] === ast &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 3 &&                this.asts[this.top] === ast : boolean
>this.count() >= 3 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>3 : 3

                this.asts[this.top] === ast &&
>this.asts[this.top] === ast : boolean
>this.asts[this.top] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top : number
>this : this
>top : number
>ast : any

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                this.asts[this.top - 2].nodeType === JumpScript.NodeType.InterfaceDeclaration;
>this.asts[this.top - 2].nodeType === JumpScript.NodeType.InterfaceDeclaration : boolean
>this.asts[this.top - 2].nodeType : any
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>nodeType : any
>JumpScript.NodeType.InterfaceDeclaration : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>InterfaceDeclaration : any
        }

        public isTopLevelImplicitModule() {
>isTopLevelImplicitModule : () => any

            return this.count() >= 1 &&
>this.count() >= 1 &&                this.asts[this.top].nodeType === JumpScript.NodeType.ModuleDeclaration &&                JumpScript.hasFlag((<JumpScript.ModuleDeclaration>this.asts[this.top]).modFlags, JumpScript.ModuleFlags.IsWholeFile) : any
>this.count() >= 1 &&                this.asts[this.top].nodeType === JumpScript.NodeType.ModuleDeclaration : boolean
>this.count() >= 1 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>1 : 1

                this.asts[this.top].nodeType === JumpScript.NodeType.ModuleDeclaration &&
>this.asts[this.top].nodeType === JumpScript.NodeType.ModuleDeclaration : boolean
>this.asts[this.top].nodeType : any
>this.asts[this.top] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top : number
>this : this
>top : number
>nodeType : any
>JumpScript.NodeType.ModuleDeclaration : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ModuleDeclaration : any

                JumpScript.hasFlag((<JumpScript.ModuleDeclaration>this.asts[this.top]).modFlags, JumpScript.ModuleFlags.IsWholeFile);
>JumpScript.hasFlag((<JumpScript.ModuleDeclaration>this.asts[this.top]).modFlags, JumpScript.ModuleFlags.IsWholeFile) : any
>JumpScript.hasFlag : any
>JumpScript : typeof JumpScript
>hasFlag : any
>(<JumpScript.ModuleDeclaration>this.asts[this.top]).modFlags : any
>(<JumpScript.ModuleDeclaration>this.asts[this.top]) : any
><JumpScript.ModuleDeclaration>this.asts[this.top] : any
>JumpScript : any
>ModuleDeclaration : No type information available!
>this.asts[this.top] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top : number
>this : this
>top : number
>modFlags : any
>JumpScript.ModuleFlags.IsWholeFile : any
>JumpScript.ModuleFlags : any
>JumpScript : typeof JumpScript
>ModuleFlags : any
>IsWholeFile : any
        }

        public isBodyOfTopLevelImplicitModule() {
>isBodyOfTopLevelImplicitModule : () => any

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ModuleDeclaration &&                 (<JumpScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] &&                JumpScript.hasFlag((<JumpScript.ModuleDeclaration>this.asts[this.top - 1]).modFlags, JumpScript.ModuleFlags.IsWholeFile) : any
>this.count() >= 2 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ModuleDeclaration &&                 (<JumpScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ModuleDeclaration : boolean
>this.count() >= 2 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 0].nodeType : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ModuleDeclaration &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.ModuleDeclaration : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.ModuleDeclaration : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ModuleDeclaration : any

                 (<JumpScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] &&
>(<JumpScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] : boolean
>(<JumpScript.ModuleDeclaration>this.asts[this.top - 1]).members : any
>(<JumpScript.ModuleDeclaration>this.asts[this.top - 1]) : any
><JumpScript.ModuleDeclaration>this.asts[this.top - 1] : any
>JumpScript : any
>ModuleDeclaration : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>members : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0

                JumpScript.hasFlag((<JumpScript.ModuleDeclaration>this.asts[this.top - 1]).modFlags, JumpScript.ModuleFlags.IsWholeFile);
>JumpScript.hasFlag((<JumpScript.ModuleDeclaration>this.asts[this.top - 1]).modFlags, JumpScript.ModuleFlags.IsWholeFile) : any
>JumpScript.hasFlag : any
>JumpScript : typeof JumpScript
>hasFlag : any
>(<JumpScript.ModuleDeclaration>this.asts[this.top - 1]).modFlags : any
>(<JumpScript.ModuleDeclaration>this.asts[this.top - 1]) : any
><JumpScript.ModuleDeclaration>this.asts[this.top - 1] : any
>JumpScript : any
>ModuleDeclaration : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>modFlags : any
>JumpScript.ModuleFlags.IsWholeFile : any
>JumpScript.ModuleFlags : any
>JumpScript : typeof JumpScript
>ModuleFlags : any
>IsWholeFile : any
        }

        public isBodyOfScript(): boolean {
>isBodyOfScript : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Script &&                 (<JumpScript.Script>this.asts[this.top - 1]).bod == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Script : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Script &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.Script : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.Script : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Script : any

                 (<JumpScript.Script>this.asts[this.top - 1]).bod == this.asts[this.top - 0];
>(<JumpScript.Script>this.asts[this.top - 1]).bod == this.asts[this.top - 0] : boolean
>(<JumpScript.Script>this.asts[this.top - 1]).bod : any
>(<JumpScript.Script>this.asts[this.top - 1]) : any
><JumpScript.Script>this.asts[this.top - 1] : any
>JumpScript : any
>Script : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>bod : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfSwitch(): boolean {
>isBodyOfSwitch : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Switch &&                 (<JumpScript.SwitchStatement>this.asts[this.top - 1]).caseList == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Switch : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Switch &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.Switch : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.Switch : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Switch : any

                 (<JumpScript.SwitchStatement>this.asts[this.top - 1]).caseList == this.asts[this.top - 0];
>(<JumpScript.SwitchStatement>this.asts[this.top - 1]).caseList == this.asts[this.top - 0] : boolean
>(<JumpScript.SwitchStatement>this.asts[this.top - 1]).caseList : any
>(<JumpScript.SwitchStatement>this.asts[this.top - 1]) : any
><JumpScript.SwitchStatement>this.asts[this.top - 1] : any
>JumpScript : any
>SwitchStatement : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>caseList : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfModule(): boolean {
>isBodyOfModule : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ModuleDeclaration &&                 (<JumpScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ModuleDeclaration : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ModuleDeclaration &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.ModuleDeclaration : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.ModuleDeclaration : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ModuleDeclaration : any

                 (<JumpScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];
>(<JumpScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] : boolean
>(<JumpScript.ModuleDeclaration>this.asts[this.top - 1]).members : any
>(<JumpScript.ModuleDeclaration>this.asts[this.top - 1]) : any
><JumpScript.ModuleDeclaration>this.asts[this.top - 1] : any
>JumpScript : any
>ModuleDeclaration : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>members : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfClass(): boolean {
>isBodyOfClass : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ClassDeclaration &&                 (<JumpScript.ClassDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ClassDeclaration : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ClassDeclaration &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.ClassDeclaration : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.ClassDeclaration : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ClassDeclaration : any

                 (<JumpScript.ClassDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];
>(<JumpScript.ClassDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] : boolean
>(<JumpScript.ClassDeclaration>this.asts[this.top - 1]).members : any
>(<JumpScript.ClassDeclaration>this.asts[this.top - 1]) : any
><JumpScript.ClassDeclaration>this.asts[this.top - 1] : any
>JumpScript : any
>ClassDeclaration : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>members : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfFunction(): boolean {
>isBodyOfFunction : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.FuncDecl &&                 (<JumpScript.FuncDecl>this.asts[this.top - 1]).bod == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.FuncDecl : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.FuncDecl &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.FuncDecl : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.FuncDecl : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>FuncDecl : any

                 (<JumpScript.FuncDecl>this.asts[this.top - 1]).bod == this.asts[this.top - 0];
>(<JumpScript.FuncDecl>this.asts[this.top - 1]).bod == this.asts[this.top - 0] : boolean
>(<JumpScript.FuncDecl>this.asts[this.top - 1]).bod : any
>(<JumpScript.FuncDecl>this.asts[this.top - 1]) : any
><JumpScript.FuncDecl>this.asts[this.top - 1] : any
>JumpScript : any
>FuncDecl : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>bod : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfInterface(): boolean {
>isBodyOfInterface : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.InterfaceDeclaration &&                 (<JumpScript.InterfaceDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.InterfaceDeclaration : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.InterfaceDeclaration &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.InterfaceDeclaration : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.InterfaceDeclaration : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>InterfaceDeclaration : any

                 (<JumpScript.InterfaceDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];
>(<JumpScript.InterfaceDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] : boolean
>(<JumpScript.InterfaceDeclaration>this.asts[this.top - 1]).members : any
>(<JumpScript.InterfaceDeclaration>this.asts[this.top - 1]) : any
><JumpScript.InterfaceDeclaration>this.asts[this.top - 1] : any
>JumpScript : any
>InterfaceDeclaration : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>members : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfBlock(): boolean {
>isBodyOfBlock : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Block &&                (<JumpScript.Block>this.asts[this.top - 1]).statements == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Block : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Block &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.Block : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.Block : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Block : any

                (<JumpScript.Block>this.asts[this.top - 1]).statements == this.asts[this.top - 0];
>(<JumpScript.Block>this.asts[this.top - 1]).statements == this.asts[this.top - 0] : boolean
>(<JumpScript.Block>this.asts[this.top - 1]).statements : any
>(<JumpScript.Block>this.asts[this.top - 1]) : any
><JumpScript.Block>this.asts[this.top - 1] : any
>JumpScript : any
>Block : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>statements : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfFor(): boolean {
>isBodyOfFor : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.For &&                (<JumpScript.ForStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.For : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.For &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.For : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.For : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>For : any

                (<JumpScript.ForStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];
>(<JumpScript.ForStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>(<JumpScript.ForStatement>this.asts[this.top - 1]).body : any
>(<JumpScript.ForStatement>this.asts[this.top - 1]) : any
><JumpScript.ForStatement>this.asts[this.top - 1] : any
>JumpScript : any
>ForStatement : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>body : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfCase(): boolean {
>isBodyOfCase : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Case &&                (<JumpScript.CaseStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Case : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Case &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.Case : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.Case : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Case : any

                (<JumpScript.CaseStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];
>(<JumpScript.CaseStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>(<JumpScript.CaseStatement>this.asts[this.top - 1]).body : any
>(<JumpScript.CaseStatement>this.asts[this.top - 1]) : any
><JumpScript.CaseStatement>this.asts[this.top - 1] : any
>JumpScript : any
>CaseStatement : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>body : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfTry(): boolean {
>isBodyOfTry : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Try &&                (<JumpScript.Try>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Try : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Try &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.Try : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.Try : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Try : any

                (<JumpScript.Try>this.asts[this.top - 1]).body == this.asts[this.top - 0];
>(<JumpScript.Try>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>(<JumpScript.Try>this.asts[this.top - 1]).body : any
>(<JumpScript.Try>this.asts[this.top - 1]) : any
><JumpScript.Try>this.asts[this.top - 1] : any
>JumpScript : any
>Try : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>body : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfCatch(): boolean {
>isBodyOfCatch : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Catch &&                (<JumpScript.Catch>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Catch : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Catch &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.Catch : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.Catch : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Catch : any

                (<JumpScript.Catch>this.asts[this.top - 1]).body == this.asts[this.top - 0];
>(<JumpScript.Catch>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>(<JumpScript.Catch>this.asts[this.top - 1]).body : any
>(<JumpScript.Catch>this.asts[this.top - 1]) : any
><JumpScript.Catch>this.asts[this.top - 1] : any
>JumpScript : any
>Catch : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>body : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfDoWhile(): boolean {
>isBodyOfDoWhile : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.DoWhile &&                (<JumpScript.DoWhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.DoWhile : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.DoWhile &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.DoWhile : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.DoWhile : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>DoWhile : any

                (<JumpScript.DoWhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];
>(<JumpScript.DoWhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>(<JumpScript.DoWhileStatement>this.asts[this.top - 1]).body : any
>(<JumpScript.DoWhileStatement>this.asts[this.top - 1]) : any
><JumpScript.DoWhileStatement>this.asts[this.top - 1] : any
>JumpScript : any
>DoWhileStatement : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>body : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfWhile(): boolean {
>isBodyOfWhile : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.While &&                (<JumpScript.WhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.While : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.While &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.While : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.While : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>While : any

                (<JumpScript.WhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];
>(<JumpScript.WhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>(<JumpScript.WhileStatement>this.asts[this.top - 1]).body : any
>(<JumpScript.WhileStatement>this.asts[this.top - 1]) : any
><JumpScript.WhileStatement>this.asts[this.top - 1] : any
>JumpScript : any
>WhileStatement : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>body : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfForIn(): boolean {
>isBodyOfForIn : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ForIn &&                (<JumpScript.ForInStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ForIn : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ForIn &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.ForIn : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.ForIn : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ForIn : any

                (<JumpScript.ForInStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];
>(<JumpScript.ForInStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>(<JumpScript.ForInStatement>this.asts[this.top - 1]).body : any
>(<JumpScript.ForInStatement>this.asts[this.top - 1]) : any
><JumpScript.ForInStatement>this.asts[this.top - 1] : any
>JumpScript : any
>ForInStatement : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>body : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfWith(): boolean {
>isBodyOfWith : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.With &&                (<JumpScript.WithStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.With : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.With &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.With : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.With : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>With : any

                (<JumpScript.WithStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];
>(<JumpScript.WithStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>(<JumpScript.WithStatement>this.asts[this.top - 1]).body : any
>(<JumpScript.WithStatement>this.asts[this.top - 1]) : any
><JumpScript.WithStatement>this.asts[this.top - 1] : any
>JumpScript : any
>WithStatement : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>body : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfFinally(): boolean {
>isBodyOfFinally : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Finally &&                (<JumpScript.Finally>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Finally : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Finally &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.Finally : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.Finally : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Finally : any

                (<JumpScript.Finally>this.asts[this.top - 1]).body == this.asts[this.top - 0];
>(<JumpScript.Finally>this.asts[this.top - 1]).body == this.asts[this.top - 0] : boolean
>(<JumpScript.Finally>this.asts[this.top - 1]).body : any
>(<JumpScript.Finally>this.asts[this.top - 1]) : any
><JumpScript.Finally>this.asts[this.top - 1] : any
>JumpScript : any
>Finally : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>body : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isCaseOfSwitch(): boolean {
>isCaseOfSwitch : () => boolean

            return this.count() >= 3 &&
>this.count() >= 3 &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.Switch &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                (<JumpScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1] : boolean
>this.count() >= 3 &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.Switch &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 3 &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.Switch : boolean
>this.count() >= 3 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>3 : 3

                this.asts[this.top - 2].nodeType === JumpScript.NodeType.Switch &&
>this.asts[this.top - 2].nodeType === JumpScript.NodeType.Switch : boolean
>this.asts[this.top - 2].nodeType : any
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>nodeType : any
>JumpScript.NodeType.Switch : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Switch : any

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                (<JumpScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1];
>(<JumpScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1] : boolean
>(<JumpScript.SwitchStatement>this.asts[this.top - 2]).caseList : any
>(<JumpScript.SwitchStatement>this.asts[this.top - 2]) : any
><JumpScript.SwitchStatement>this.asts[this.top - 2] : any
>JumpScript : any
>SwitchStatement : No type information available!
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>caseList : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
        }

        public isDefaultCaseOfSwitch(): boolean {
>isDefaultCaseOfSwitch : () => boolean

            return this.count() >= 3 &&
>this.count() >= 3 &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.Switch &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                (<JumpScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1] &&                (<JumpScript.SwitchStatement>this.asts[this.top - 2]).defaultCase == this.asts[this.top - 0] : boolean
>this.count() >= 3 &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.Switch &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                (<JumpScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1] : boolean
>this.count() >= 3 &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.Switch &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 3 &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.Switch : boolean
>this.count() >= 3 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>3 : 3

                this.asts[this.top - 2].nodeType === JumpScript.NodeType.Switch &&
>this.asts[this.top - 2].nodeType === JumpScript.NodeType.Switch : boolean
>this.asts[this.top - 2].nodeType : any
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>nodeType : any
>JumpScript.NodeType.Switch : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Switch : any

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                (<JumpScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1] &&
>(<JumpScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1] : boolean
>(<JumpScript.SwitchStatement>this.asts[this.top - 2]).caseList : any
>(<JumpScript.SwitchStatement>this.asts[this.top - 2]) : any
><JumpScript.SwitchStatement>this.asts[this.top - 2] : any
>JumpScript : any
>SwitchStatement : No type information available!
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>caseList : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1

                (<JumpScript.SwitchStatement>this.asts[this.top - 2]).defaultCase == this.asts[this.top - 0];
>(<JumpScript.SwitchStatement>this.asts[this.top - 2]).defaultCase == this.asts[this.top - 0] : boolean
>(<JumpScript.SwitchStatement>this.asts[this.top - 2]).defaultCase : any
>(<JumpScript.SwitchStatement>this.asts[this.top - 2]) : any
><JumpScript.SwitchStatement>this.asts[this.top - 2] : any
>JumpScript : any
>SwitchStatement : No type information available!
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>defaultCase : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isListOfObjectLit(): boolean {
>isListOfObjectLit : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ObjectLit &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&                (<JumpScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ObjectLit &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ObjectLit : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ObjectLit &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.ObjectLit : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.ObjectLit : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ObjectLit : any

                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 0].nodeType : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                (<JumpScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];
>(<JumpScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0] : boolean
>(<JumpScript.UnaryExpression>this.asts[this.top - 1]).operand : any
>(<JumpScript.UnaryExpression>this.asts[this.top - 1]) : any
><JumpScript.UnaryExpression>this.asts[this.top - 1] : any
>JumpScript : any
>UnaryExpression : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>operand : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfObjectLit(): boolean {
>isBodyOfObjectLit : () => boolean

            return this.isListOfObjectLit();
>this.isListOfObjectLit() : boolean
>this.isListOfObjectLit : () => boolean
>this : this
>isListOfObjectLit : () => boolean
        }

        public isEmptyListOfObjectLit(): boolean {
>isEmptyListOfObjectLit : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ObjectLit &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&                (<JumpScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0] &&                (<JumpScript.ASTList>this.asts[this.top - 0]).members.length == 0 : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ObjectLit &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&                (<JumpScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ObjectLit &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ObjectLit : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ObjectLit &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.ObjectLit : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.ObjectLit : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ObjectLit : any

                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 0].nodeType : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                (<JumpScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0] &&
>(<JumpScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0] : boolean
>(<JumpScript.UnaryExpression>this.asts[this.top - 1]).operand : any
>(<JumpScript.UnaryExpression>this.asts[this.top - 1]) : any
><JumpScript.UnaryExpression>this.asts[this.top - 1] : any
>JumpScript : any
>UnaryExpression : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>operand : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0

                (<JumpScript.ASTList>this.asts[this.top - 0]).members.length == 0;
>(<JumpScript.ASTList>this.asts[this.top - 0]).members.length == 0 : boolean
>(<JumpScript.ASTList>this.asts[this.top - 0]).members.length : any
>(<JumpScript.ASTList>this.asts[this.top - 0]).members : any
>(<JumpScript.ASTList>this.asts[this.top - 0]) : any
><JumpScript.ASTList>this.asts[this.top - 0] : any
>JumpScript : any
>ASTList : No type information available!
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
>members : any
>length : any
>0 : 0
        }

        public isMemberOfObjectLit(): boolean {
>isMemberOfObjectLit : () => boolean

            return this.count() >= 3 &&
>this.count() >= 3 &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.ObjectLit &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.Member &&                (<JumpScript.UnaryExpression>this.asts[this.top - 2]).operand == this.asts[this.top - 1] : boolean
>this.count() >= 3 &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.ObjectLit &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.Member : boolean
>this.count() >= 3 &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.ObjectLit &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 3 &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.ObjectLit : boolean
>this.count() >= 3 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>3 : 3

                this.asts[this.top - 2].nodeType === JumpScript.NodeType.ObjectLit &&
>this.asts[this.top - 2].nodeType === JumpScript.NodeType.ObjectLit : boolean
>this.asts[this.top - 2].nodeType : any
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>nodeType : any
>JumpScript.NodeType.ObjectLit : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ObjectLit : any

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                this.asts[this.top - 0].nodeType === JumpScript.NodeType.Member &&
>this.asts[this.top - 0].nodeType === JumpScript.NodeType.Member : boolean
>this.asts[this.top - 0].nodeType : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
>nodeType : any
>JumpScript.NodeType.Member : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Member : any

                (<JumpScript.UnaryExpression>this.asts[this.top - 2]).operand == this.asts[this.top - 1];
>(<JumpScript.UnaryExpression>this.asts[this.top - 2]).operand == this.asts[this.top - 1] : boolean
>(<JumpScript.UnaryExpression>this.asts[this.top - 2]).operand : any
>(<JumpScript.UnaryExpression>this.asts[this.top - 2]) : any
><JumpScript.UnaryExpression>this.asts[this.top - 2] : any
>JumpScript : any
>UnaryExpression : No type information available!
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>operand : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
        }

        public isNameOfMemberOfObjectLit(): boolean {
>isNameOfMemberOfObjectLit : () => boolean

            return this.count() >= 4 &&
>this.count() >= 4 &&                this.asts[this.top - 3].nodeType === JumpScript.NodeType.ObjectLit &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Member &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.Name &&                (<JumpScript.UnaryExpression>this.asts[this.top - 3]).operand == this.asts[this.top - 2] : boolean
>this.count() >= 4 &&                this.asts[this.top - 3].nodeType === JumpScript.NodeType.ObjectLit &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Member &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.Name : boolean
>this.count() >= 4 &&                this.asts[this.top - 3].nodeType === JumpScript.NodeType.ObjectLit &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Member : boolean
>this.count() >= 4 &&                this.asts[this.top - 3].nodeType === JumpScript.NodeType.ObjectLit &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 4 &&                this.asts[this.top - 3].nodeType === JumpScript.NodeType.ObjectLit : boolean
>this.count() >= 4 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>4 : 4

                this.asts[this.top - 3].nodeType === JumpScript.NodeType.ObjectLit &&
>this.asts[this.top - 3].nodeType === JumpScript.NodeType.ObjectLit : boolean
>this.asts[this.top - 3].nodeType : any
>this.asts[this.top - 3] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 3 : number
>this.top : number
>this : this
>top : number
>3 : 3
>nodeType : any
>JumpScript.NodeType.ObjectLit : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ObjectLit : any

                this.asts[this.top - 2].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 2].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 2].nodeType : any
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Member &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.Member : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.Member : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Member : any

                this.asts[this.top - 0].nodeType === JumpScript.NodeType.Name &&
>this.asts[this.top - 0].nodeType === JumpScript.NodeType.Name : boolean
>this.asts[this.top - 0].nodeType : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
>nodeType : any
>JumpScript.NodeType.Name : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Name : any

                (<JumpScript.UnaryExpression>this.asts[this.top - 3]).operand == this.asts[this.top - 2];
>(<JumpScript.UnaryExpression>this.asts[this.top - 3]).operand == this.asts[this.top - 2] : boolean
>(<JumpScript.UnaryExpression>this.asts[this.top - 3]).operand : any
>(<JumpScript.UnaryExpression>this.asts[this.top - 3]) : any
><JumpScript.UnaryExpression>this.asts[this.top - 3] : any
>JumpScript : any
>UnaryExpression : No type information available!
>this.asts[this.top - 3] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 3 : number
>this.top : number
>this : this
>top : number
>3 : 3
>operand : any
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
        }

        public isListOfArrayLit(): boolean {
>isListOfArrayLit : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ArrayLit &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&                (<JumpScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ArrayLit &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ArrayLit : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.ArrayLit &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.ArrayLit : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.ArrayLit : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>ArrayLit : any

                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 0].nodeType : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                (<JumpScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];
>(<JumpScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0] : boolean
>(<JumpScript.UnaryExpression>this.asts[this.top - 1]).operand : any
>(<JumpScript.UnaryExpression>this.asts[this.top - 1]) : any
><JumpScript.UnaryExpression>this.asts[this.top - 1] : any
>JumpScript : any
>UnaryExpression : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>operand : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isTargetOfMember(): boolean {
>isTargetOfMember : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Member &&                (<JumpScript.BinaryExpression>this.asts[this.top - 1]).operand1 === this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Member : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Member &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.Member : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.Member : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Member : any

                (<JumpScript.BinaryExpression>this.asts[this.top - 1]).operand1 === this.asts[this.top - 0];
>(<JumpScript.BinaryExpression>this.asts[this.top - 1]).operand1 === this.asts[this.top - 0] : boolean
>(<JumpScript.BinaryExpression>this.asts[this.top - 1]).operand1 : any
>(<JumpScript.BinaryExpression>this.asts[this.top - 1]) : any
><JumpScript.BinaryExpression>this.asts[this.top - 1] : any
>JumpScript : any
>BinaryExpression : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>operand1 : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isMemberOfMember(): boolean {
>isMemberOfMember : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Member &&                (<JumpScript.BinaryExpression>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Member : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Member &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.Member : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.Member : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Member : any

                (<JumpScript.BinaryExpression>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];
>(<JumpScript.BinaryExpression>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0] : boolean
>(<JumpScript.BinaryExpression>this.asts[this.top - 1]).operand2 : any
>(<JumpScript.BinaryExpression>this.asts[this.top - 1]) : any
><JumpScript.BinaryExpression>this.asts[this.top - 1] : any
>JumpScript : any
>BinaryExpression : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>operand2 : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isItemOfList(): boolean {
>isItemOfList : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List;
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

            //(<Tools.ASTList>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];
        }

        public isThenOfIf(): boolean {
>isThenOfIf : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.If &&                (<JumpScript.IfStatement>this.asts[this.top - 1]).thenBod == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.If : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.If &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.If : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.If : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>If : any

                (<JumpScript.IfStatement>this.asts[this.top - 1]).thenBod == this.asts[this.top - 0];
>(<JumpScript.IfStatement>this.asts[this.top - 1]).thenBod == this.asts[this.top - 0] : boolean
>(<JumpScript.IfStatement>this.asts[this.top - 1]).thenBod : any
>(<JumpScript.IfStatement>this.asts[this.top - 1]) : any
><JumpScript.IfStatement>this.asts[this.top - 1] : any
>JumpScript : any
>IfStatement : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>thenBod : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isElseOfIf(): boolean {
>isElseOfIf : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.If &&                (<JumpScript.IfStatement>this.asts[this.top - 1]).elseBod == this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.If : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.If &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.If : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.If : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>If : any

                (<JumpScript.IfStatement>this.asts[this.top - 1]).elseBod == this.asts[this.top - 0];
>(<JumpScript.IfStatement>this.asts[this.top - 1]).elseBod == this.asts[this.top - 0] : boolean
>(<JumpScript.IfStatement>this.asts[this.top - 1]).elseBod : any
>(<JumpScript.IfStatement>this.asts[this.top - 1]) : any
><JumpScript.IfStatement>this.asts[this.top - 1] : any
>JumpScript : any
>IfStatement : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>elseBod : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isBodyOfDefaultCase(): boolean {
>isBodyOfDefaultCase : () => boolean

            return this.isBodyOfCase();
>this.isBodyOfCase() : boolean
>this.isBodyOfCase : () => boolean
>this : this
>isBodyOfCase : () => boolean
        }

        public isSingleStatementList(): boolean {
>isSingleStatementList : () => boolean

            return this.count() >= 1 &&
>this.count() >= 1 &&                this.asts[this.top].nodeType === JumpScript.NodeType.List &&                (<JumpScript.ASTList>this.asts[this.top]).members.length === 1 : boolean
>this.count() >= 1 &&                this.asts[this.top].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 1 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>1 : 1

                this.asts[this.top].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top].nodeType : any
>this.asts[this.top] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top : number
>this : this
>top : number
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                (<JumpScript.ASTList>this.asts[this.top]).members.length === 1;
>(<JumpScript.ASTList>this.asts[this.top]).members.length === 1 : boolean
>(<JumpScript.ASTList>this.asts[this.top]).members.length : any
>(<JumpScript.ASTList>this.asts[this.top]).members : any
>(<JumpScript.ASTList>this.asts[this.top]) : any
><JumpScript.ASTList>this.asts[this.top] : any
>JumpScript : any
>ASTList : No type information available!
>this.asts[this.top] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top : number
>this : this
>top : number
>members : any
>length : any
>1 : 1
        }

        public isArgumentListOfFunction(): boolean {
>isArgumentListOfFunction : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.FuncDecl &&                (<JumpScript.FuncDecl>this.asts[this.top - 1]).arguments === this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.FuncDecl : boolean
>this.count() >= 2 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 0].nodeType : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.FuncDecl &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.FuncDecl : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.FuncDecl : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>FuncDecl : any

                (<JumpScript.FuncDecl>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
>(<JumpScript.FuncDecl>this.asts[this.top - 1]).arguments === this.asts[this.top - 0] : boolean
>(<JumpScript.FuncDecl>this.asts[this.top - 1]).arguments : any
>(<JumpScript.FuncDecl>this.asts[this.top - 1]) : any
><JumpScript.FuncDecl>this.asts[this.top - 1] : any
>JumpScript : any
>FuncDecl : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>arguments : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isArgumentOfFunction(): boolean {
>isArgumentOfFunction : () => boolean

            return this.count() >= 3 &&
>this.count() >= 3 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.FuncDecl &&                (<JumpScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1] : boolean
>this.count() >= 3 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 2].nodeType === JumpScript.NodeType.FuncDecl : boolean
>this.count() >= 3 &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 3 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>3 : 3

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                this.asts[this.top - 2].nodeType === JumpScript.NodeType.FuncDecl &&
>this.asts[this.top - 2].nodeType === JumpScript.NodeType.FuncDecl : boolean
>this.asts[this.top - 2].nodeType : any
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>nodeType : any
>JumpScript.NodeType.FuncDecl : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>FuncDecl : any

                (<JumpScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1];
>(<JumpScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1] : boolean
>(<JumpScript.FuncDecl>this.asts[this.top - 2]).arguments : any
>(<JumpScript.FuncDecl>this.asts[this.top - 2]) : any
><JumpScript.FuncDecl>this.asts[this.top - 2] : any
>JumpScript : any
>FuncDecl : No type information available!
>this.asts[this.top - 2] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 2 : number
>this.top : number
>this : this
>top : number
>2 : 2
>arguments : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
        }

        public isArgumentListOfCall(): boolean {
>isArgumentListOfCall : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Call &&                (<JumpScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Call : boolean
>this.count() >= 2 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 0].nodeType : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.Call &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.Call : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.Call : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Call : any

                (<JumpScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
>(<JumpScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0] : boolean
>(<JumpScript.CallExpression>this.asts[this.top - 1]).arguments : any
>(<JumpScript.CallExpression>this.asts[this.top - 1]) : any
><JumpScript.CallExpression>this.asts[this.top - 1] : any
>JumpScript : any
>CallExpression : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>arguments : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isArgumentListOfNew(): boolean {
>isArgumentListOfNew : () => boolean

            return this.count() >= 2 &&
>this.count() >= 2 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.New &&                (<JumpScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0] : boolean
>this.count() >= 2 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&                this.asts[this.top - 1].nodeType === JumpScript.NodeType.New : boolean
>this.count() >= 2 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.count() >= 2 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>2 : 2

                this.asts[this.top - 0].nodeType === JumpScript.NodeType.List &&
>this.asts[this.top - 0].nodeType === JumpScript.NodeType.List : boolean
>this.asts[this.top - 0].nodeType : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
>nodeType : any
>JumpScript.NodeType.List : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>List : any

                this.asts[this.top - 1].nodeType === JumpScript.NodeType.New &&
>this.asts[this.top - 1].nodeType === JumpScript.NodeType.New : boolean
>this.asts[this.top - 1].nodeType : any
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>nodeType : any
>JumpScript.NodeType.New : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>New : any

                (<JumpScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
>(<JumpScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0] : boolean
>(<JumpScript.CallExpression>this.asts[this.top - 1]).arguments : any
>(<JumpScript.CallExpression>this.asts[this.top - 1]) : any
><JumpScript.CallExpression>this.asts[this.top - 1] : any
>JumpScript : any
>CallExpression : No type information available!
>this.asts[this.top - 1] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 1 : number
>this.top : number
>this : this
>top : number
>1 : 1
>arguments : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
        }

        public isSynthesizedBlock(): boolean {
>isSynthesizedBlock : () => boolean

            return this.count() >= 1 &&
>this.count() >= 1 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.Block &&                (<JumpScript.Block>this.asts[this.top - 0]).isStatementBlock === false : boolean
>this.count() >= 1 &&                this.asts[this.top - 0].nodeType === JumpScript.NodeType.Block : boolean
>this.count() >= 1 : boolean
>this.count() : number
>this.count : () => number
>this : this
>count : () => number
>1 : 1

                this.asts[this.top - 0].nodeType === JumpScript.NodeType.Block &&
>this.asts[this.top - 0].nodeType === JumpScript.NodeType.Block : boolean
>this.asts[this.top - 0].nodeType : any
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
>nodeType : any
>JumpScript.NodeType.Block : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Block : any

                (<JumpScript.Block>this.asts[this.top - 0]).isStatementBlock === false;
>(<JumpScript.Block>this.asts[this.top - 0]).isStatementBlock === false : boolean
>(<JumpScript.Block>this.asts[this.top - 0]).isStatementBlock : any
>(<JumpScript.Block>this.asts[this.top - 0]) : any
><JumpScript.Block>this.asts[this.top - 0] : any
>JumpScript : any
>Block : No type information available!
>this.asts[this.top - 0] : any
>this.asts : any[]
>this : this
>asts : any[]
>this.top - 0 : number
>this.top : number
>this : this
>top : number
>0 : 0
>isStatementBlock : any
>false : false
        }
    }

    export function isValidAstNode(ast: JumpScript.ASTSpan): boolean {
>isValidAstNode : (ast: any) => boolean
>ast : any
>JumpScript : any
>ASTSpan : No type information available!

        if (ast === null)
>ast === null : boolean
>ast : any
>null : null

            return false;
>false : false

        if (ast.minChar === -1 || ast.limChar === -1)
>ast.minChar === -1 || ast.limChar === -1 : boolean
>ast.minChar === -1 : boolean
>ast.minChar : any
>ast : any
>minChar : any
>-1 : -1
>1 : 1
>ast.limChar === -1 : boolean
>ast.limChar : any
>ast : any
>limChar : any
>-1 : -1
>1 : 1

            return false;
>false : false

        return true;
>true : true
    }

    export class AstPathContext {
>AstPathContext : AstPathContext

        public path = new JumpScript.AstPath();
>path : AstPath
>new JumpScript.AstPath() : AstPath
>JumpScript.AstPath : typeof AstPath
>JumpScript : typeof JumpScript
>AstPath : typeof AstPath
    }

    export enum GetAstPathOptions {
>GetAstPathOptions : GetAstPathOptions

        Default = 0,
>Default : GetAstPathOptions
>0 : 0

        EdgeInclusive = 1,
>EdgeInclusive : GetAstPathOptions
>1 : 1

        //We need this options dealing with an AST coming from an incomplete AST. For example:
        //     class foo { // r
        // If we ask for the AST at the position after the "r" character, we won't see we are 
        // inside a comment, because the "class" AST node has a limChar corresponding to the position of 
        // the "{" character, meaning we don't traverse the tree down to the stmt list of the class, meaning
        // we don't find the "precomment" attached to the errorneous empty stmt.
        //TODO: It would be nice to be able to get rid of this.
        DontPruneSearchBasedOnPosition = 1 << 1,
>DontPruneSearchBasedOnPosition : GetAstPathOptions
>1 << 1 : number
>1 : 1
>1 : 1
    }

    ///
    /// Return the stack of AST nodes containing "position"
    ///
    export function getAstPathToPosition(script: JumpScript.AST, pos: number, options = GetAstPathOptions.Default): JumpScript.AstPath {
>getAstPathToPosition : (script: any, pos: number, options?: GetAstPathOptions) => AstPath
>script : any
>JumpScript : any
>AST : No type information available!
>pos : number
>options : GetAstPathOptions
>GetAstPathOptions.Default : GetAstPathOptions
>GetAstPathOptions : typeof GetAstPathOptions
>Default : GetAstPathOptions
>JumpScript : any
>AstPath : AstPath

        var lookInComments = (comments: JumpScript.Comment[]) => {
>lookInComments : (comments: any[]) => void
>(comments: JumpScript.Comment[]) => {            if (comments && comments.length > 0) {                for (var i = 0; i < comments.length; i++) {                    var minChar = comments[i].minChar;                    var limChar = comments[i].limChar;                    if (!comments[i].isBlockComment) {                        limChar++; // For single line comments, include 1 more character (for the newline)                    }                    if (pos >= minChar && pos < limChar) {                        ctx.path.push(comments[i]);                    }                }            }        } : (comments: any[]) => void
>comments : any[]
>JumpScript : any
>Comment : No type information available!

            if (comments && comments.length > 0) {
>comments && comments.length > 0 : boolean
>comments : any[]
>comments.length > 0 : boolean
>comments.length : number
>comments : any[]
>length : number
>0 : 0

                for (var i = 0; i < comments.length; i++) {
>i : number
>0 : 0
>i < comments.length : boolean
>i : number
>comments.length : number
>comments : any[]
>length : number
>i++ : number
>i : number

                    var minChar = comments[i].minChar;
>minChar : any
>comments[i].minChar : any
>comments[i] : any
>comments : any[]
>i : number
>minChar : any

                    var limChar = comments[i].limChar;
>limChar : any
>comments[i].limChar : any
>comments[i] : any
>comments : any[]
>i : number
>limChar : any

                    if (!comments[i].isBlockComment) {
>!comments[i].isBlockComment : boolean
>comments[i].isBlockComment : any
>comments[i] : any
>comments : any[]
>i : number
>isBlockComment : any

                        limChar++; // For single line comments, include 1 more character (for the newline)
>limChar++ : number
>limChar : any
                    }
                    if (pos >= minChar && pos < limChar) {
>pos >= minChar && pos < limChar : boolean
>pos >= minChar : boolean
>pos : number
>minChar : any
>pos < limChar : boolean
>pos : number
>limChar : any

                        ctx.path.push(comments[i]);
>ctx.path.push(comments[i]) : void
>ctx.path.push : (ast: any) => void
>ctx.path : AstPath
>ctx : AstPathContext
>path : AstPath
>push : (ast: any) => void
>comments[i] : any
>comments : any[]
>i : number
                    }
                }
            }
        }

        var pre = function (cur: JumpScript.AST, parent: JumpScript.AST, walker: IAstWalker) {
>pre : (cur: any, parent: any, walker: any) => any
>function (cur: JumpScript.AST, parent: JumpScript.AST, walker: IAstWalker) {            if (isValidAstNode(cur)) {                // Add "cur" to the stack if it contains our position                // For "identifier" nodes, we need a special case: A position equal to "limChar" is                // valid, since the position corresponds to a caret position (in between characters)                // For example:                //  bar                //  0123                // If "position == 3", the caret is at the "right" of the "r" character, which should be considered valid                var inclusive =                    hasFlag(options, GetAstPathOptions.EdgeInclusive) ||                    cur.nodeType === JumpScript.NodeType.Name ||                    pos === script.limChar; // Special "EOF" case                var minChar = cur.minChar;                var limChar = cur.limChar + (inclusive ? 1 : 0)                if (pos >= minChar && pos < limChar) {                    // TODO: Since AST is sometimes not correct wrt to position, only add "cur" if it's better                    //       than top of the stack.                    var previous = ctx.path.ast();                    if (previous == null || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {                        ctx.path.push(cur);                    }                    else {                        //logger.log("TODO: Ignoring node because minChar, limChar not better than previous node in stack");                    }                }                // The AST walker skips comments, but we might be in one, so check the pre/post comments for this node manually                if (pos < limChar) {                    lookInComments(cur.preComments);                }                if (pos >= minChar) {                    lookInComments(cur.postComments);                }                if (!hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition)) {                    // Don't go further down the tree if pos is outside of [minChar, limChar]                    walker.options.goChildren = (minChar <= pos && pos <= limChar);                }            }            return cur;        } : (cur: any, parent: any, walker: any) => any
>cur : any
>JumpScript : any
>AST : No type information available!
>parent : any
>JumpScript : any
>AST : No type information available!
>walker : any
>IAstWalker : No type information available!

            if (isValidAstNode(cur)) {
>isValidAstNode(cur) : boolean
>isValidAstNode : (ast: any) => boolean
>cur : any

                // Add "cur" to the stack if it contains our position
                // For "identifier" nodes, we need a special case: A position equal to "limChar" is
                // valid, since the position corresponds to a caret position (in between characters)
                // For example:
                //  bar
                //  0123
                // If "position == 3", the caret is at the "right" of the "r" character, which should be considered valid
                var inclusive =
>inclusive : any

                    hasFlag(options, GetAstPathOptions.EdgeInclusive) ||
>hasFlag(options, GetAstPathOptions.EdgeInclusive) ||                    cur.nodeType === JumpScript.NodeType.Name ||                    pos === script.limChar : any
>hasFlag(options, GetAstPathOptions.EdgeInclusive) ||                    cur.nodeType === JumpScript.NodeType.Name : any
>hasFlag(options, GetAstPathOptions.EdgeInclusive) : any
>hasFlag : any
>options : GetAstPathOptions
>GetAstPathOptions.EdgeInclusive : GetAstPathOptions
>GetAstPathOptions : typeof GetAstPathOptions
>EdgeInclusive : GetAstPathOptions

                    cur.nodeType === JumpScript.NodeType.Name ||
>cur.nodeType === JumpScript.NodeType.Name : boolean
>cur.nodeType : any
>cur : any
>nodeType : any
>JumpScript.NodeType.Name : any
>JumpScript.NodeType : any
>JumpScript : typeof JumpScript
>NodeType : any
>Name : any

                    pos === script.limChar; // Special "EOF" case
>pos === script.limChar : boolean
>pos : number
>script.limChar : any
>script : any
>limChar : any

                var minChar = cur.minChar;
>minChar : any
>cur.minChar : any
>cur : any
>minChar : any

                var limChar = cur.limChar + (inclusive ? 1 : 0)
>limChar : any
>cur.limChar + (inclusive ? 1 : 0) : any
>cur.limChar : any
>cur : any
>limChar : any
>(inclusive ? 1 : 0) : 0 | 1
>inclusive ? 1 : 0 : 0 | 1
>inclusive : any
>1 : 1
>0 : 0

                if (pos >= minChar && pos < limChar) {
>pos >= minChar && pos < limChar : boolean
>pos >= minChar : boolean
>pos : number
>minChar : any
>pos < limChar : boolean
>pos : number
>limChar : any

                    // TODO: Since AST is sometimes not correct wrt to position, only add "cur" if it's better
                    //       than top of the stack.
                    var previous = ctx.path.ast();
>previous : any
>ctx.path.ast() : any
>ctx.path.ast : () => any
>ctx.path : AstPath
>ctx : AstPathContext
>path : AstPath
>ast : () => any

                    if (previous == null || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {
>previous == null || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar) : boolean
>previous == null : boolean
>previous : any
>null : null
>(cur.minChar >= previous.minChar && cur.limChar <= previous.limChar) : boolean
>cur.minChar >= previous.minChar && cur.limChar <= previous.limChar : boolean
>cur.minChar >= previous.minChar : boolean
>cur.minChar : any
>cur : any
>minChar : any
>previous.minChar : any
>previous : any
>minChar : any
>cur.limChar <= previous.limChar : boolean
>cur.limChar : any
>cur : any
>limChar : any
>previous.limChar : any
>previous : any
>limChar : any

                        ctx.path.push(cur);
>ctx.path.push(cur) : void
>ctx.path.push : (ast: any) => void
>ctx.path : AstPath
>ctx : AstPathContext
>path : AstPath
>push : (ast: any) => void
>cur : any
                    }
                    else {
                        //logger.log("TODO: Ignoring node because minChar, limChar not better than previous node in stack");
                    }
                }

                // The AST walker skips comments, but we might be in one, so check the pre/post comments for this node manually
                if (pos < limChar) {
>pos < limChar : boolean
>pos : number
>limChar : any

                    lookInComments(cur.preComments);
>lookInComments(cur.preComments) : void
>lookInComments : (comments: any[]) => void
>cur.preComments : any
>cur : any
>preComments : any
                }
                if (pos >= minChar) {
>pos >= minChar : boolean
>pos : number
>minChar : any

                    lookInComments(cur.postComments);
>lookInComments(cur.postComments) : void
>lookInComments : (comments: any[]) => void
>cur.postComments : any
>cur : any
>postComments : any
                }

                if (!hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition)) {
>!hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition) : boolean
>hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition) : any
>hasFlag : any
>options : GetAstPathOptions
>GetAstPathOptions.DontPruneSearchBasedOnPosition : GetAstPathOptions
>GetAstPathOptions : typeof GetAstPathOptions
>DontPruneSearchBasedOnPosition : GetAstPathOptions

                    // Don't go further down the tree if pos is outside of [minChar, limChar]
                    walker.options.goChildren = (minChar <= pos && pos <= limChar);
>walker.options.goChildren = (minChar <= pos && pos <= limChar) : boolean
>walker.options.goChildren : any
>walker.options : any
>walker : any
>options : any
>goChildren : any
>(minChar <= pos && pos <= limChar) : boolean
>minChar <= pos && pos <= limChar : boolean
>minChar <= pos : boolean
>minChar : any
>pos : number
>pos <= limChar : boolean
>pos : number
>limChar : any
                }
            }
            return cur;
>cur : any
        }

        var ctx = new AstPathContext();
>ctx : AstPathContext
>new AstPathContext() : AstPathContext
>AstPathContext : typeof AstPathContext

        JumpScript.getAstWalkerFactory().walk(script, pre, null, null, ctx);
>JumpScript.getAstWalkerFactory().walk(script, pre, null, null, ctx) : any
>JumpScript.getAstWalkerFactory().walk : any
>JumpScript.getAstWalkerFactory() : any
>JumpScript.getAstWalkerFactory : any
>JumpScript : typeof JumpScript
>getAstWalkerFactory : any
>walk : any
>script : any
>pre : (cur: any, parent: any, walker: any) => any
>null : null
>null : null
>ctx : AstPathContext

        return ctx.path;
>ctx.path : AstPath
>ctx : AstPathContext
>path : AstPath
    }

    //
    // Find a source text offset that is safe for lexing tokens at the given position.
    // This is used when "position" might be inside a comment or string, etc.
    //
    export function getTokenizationOffset(script: JumpScript.Script, position: number): number {
>getTokenizationOffset : (script: any, position: number) => number
>script : any
>JumpScript : any
>Script : No type information available!
>position : number

        var bestOffset = 0;
>bestOffset : number
>0 : 0

        var pre = (cur: JumpScript.AST, parent: JumpScript.AST, walker: JumpScript.IAstWalker): JumpScript.AST => {
>pre : (cur: any, parent: any, walker: any) => any
>(cur: JumpScript.AST, parent: JumpScript.AST, walker: JumpScript.IAstWalker): JumpScript.AST => {            if (JumpScript.isValidAstNode(cur)) {                // Did we find a closer offset?                if (cur.minChar <= position) {                    bestOffset = max(bestOffset, cur.minChar);                }                // Stop the walk if this node is not related to "minChar"                if (cur.minChar > position || cur.limChar < bestOffset) {                    walker.options.goChildren = false;                }            }            return cur;        } : (cur: any, parent: any, walker: any) => any
>cur : any
>JumpScript : any
>AST : No type information available!
>parent : any
>JumpScript : any
>AST : No type information available!
>walker : any
>JumpScript : any
>IAstWalker : No type information available!
>JumpScript : any
>AST : No type information available!

            if (JumpScript.isValidAstNode(cur)) {
>JumpScript.isValidAstNode(cur) : boolean
>JumpScript.isValidAstNode : (ast: any) => boolean
>JumpScript : typeof JumpScript
>isValidAstNode : (ast: any) => boolean
>cur : any

                // Did we find a closer offset?
                if (cur.minChar <= position) {
>cur.minChar <= position : boolean
>cur.minChar : any
>cur : any
>minChar : any
>position : number

                    bestOffset = max(bestOffset, cur.minChar);
>bestOffset = max(bestOffset, cur.minChar) : number
>bestOffset : number
>max(bestOffset, cur.minChar) : number
>max : (a: number, b: number) => number
>bestOffset : number
>cur.minChar : any
>cur : any
>minChar : any
                }

                // Stop the walk if this node is not related to "minChar"
                if (cur.minChar > position || cur.limChar < bestOffset) {
>cur.minChar > position || cur.limChar < bestOffset : boolean
>cur.minChar > position : boolean
>cur.minChar : any
>cur : any
>minChar : any
>position : number
>cur.limChar < bestOffset : boolean
>cur.limChar : any
>cur : any
>limChar : any
>bestOffset : number

                    walker.options.goChildren = false;
>walker.options.goChildren = false : false
>walker.options.goChildren : any
>walker.options : any
>walker : any
>options : any
>goChildren : any
>false : false
                }
            }

            return cur;
>cur : any
        }

        JumpScript.getAstWalkerFactory().walk(script, pre);
>JumpScript.getAstWalkerFactory().walk(script, pre) : any
>JumpScript.getAstWalkerFactory().walk : any
>JumpScript.getAstWalkerFactory() : any
>JumpScript.getAstWalkerFactory : any
>JumpScript : typeof JumpScript
>getAstWalkerFactory : any
>walk : any
>script : any
>pre : (cur: any, parent: any, walker: any) => any

        return bestOffset;
>bestOffset : number
    }

    ///
    /// Simple function to Walk an AST using a simple callback function.
    ///
    export function walkAST(ast: JumpScript.AST, callback: (path: AstPath, walker: JumpScript.IAstWalker) => void ): void {
>walkAST : (ast: any, callback: (path: AstPath, walker: any) => void) => void
>ast : any
>JumpScript : any
>AST : No type information available!
>callback : (path: AstPath, walker: any) => void
>path : AstPath
>AstPath : AstPath
>walker : any
>JumpScript : any
>IAstWalker : No type information available!

        var pre = function (cur: JumpScript.AST, parent: JumpScript.AST, walker: JumpScript.IAstWalker) {
>pre : (cur: any, parent: any, walker: any) => any
>function (cur: JumpScript.AST, parent: JumpScript.AST, walker: JumpScript.IAstWalker) {            var path: JumpScript.AstPath = walker.state;            path.push(cur);            callback(path, walker);            return cur;        } : (cur: any, parent: any, walker: any) => any
>cur : any
>JumpScript : any
>AST : No type information available!
>parent : any
>JumpScript : any
>AST : No type information available!
>walker : any
>JumpScript : any
>IAstWalker : No type information available!

            var path: JumpScript.AstPath = walker.state;
>path : AstPath
>JumpScript : any
>AstPath : AstPath
>walker.state : any
>walker : any
>state : any

            path.push(cur);
>path.push(cur) : void
>path.push : (ast: any) => void
>path : AstPath
>push : (ast: any) => void
>cur : any

            callback(path, walker);
>callback(path, walker) : void
>callback : (path: AstPath, walker: any) => void
>path : AstPath
>walker : any

            return cur;
>cur : any
        }
        var post = function (cur: JumpScript.AST, parent: JumpScript.AST, walker: JumpScript.IAstWalker) {
>post : (cur: any, parent: any, walker: any) => any
>function (cur: JumpScript.AST, parent: JumpScript.AST, walker: JumpScript.IAstWalker) {            var path: JumpScript.AstPath = walker.state;            path.pop();            return cur;        } : (cur: any, parent: any, walker: any) => any
>cur : any
>JumpScript : any
>AST : No type information available!
>parent : any
>JumpScript : any
>AST : No type information available!
>walker : any
>JumpScript : any
>IAstWalker : No type information available!

            var path: JumpScript.AstPath = walker.state;
>path : AstPath
>JumpScript : any
>AstPath : AstPath
>walker.state : any
>walker : any
>state : any

            path.pop();
>path.pop() : any
>path.pop : () => any
>path : AstPath
>pop : () => any

            return cur;
>cur : any
        }

        var path = new AstPath();
>path : AstPath
>new AstPath() : AstPath
>AstPath : typeof AstPath

        JumpScript.getAstWalkerFactory().walk(ast, pre, post, null, path);
>JumpScript.getAstWalkerFactory().walk(ast, pre, post, null, path) : any
>JumpScript.getAstWalkerFactory().walk : any
>JumpScript.getAstWalkerFactory() : any
>JumpScript.getAstWalkerFactory : any
>JumpScript : typeof JumpScript
>getAstWalkerFactory : any
>walk : any
>ast : any
>pre : (cur: any, parent: any, walker: any) => any
>post : (cur: any, parent: any, walker: any) => any
>null : null
>path : AstPath
    }
}

