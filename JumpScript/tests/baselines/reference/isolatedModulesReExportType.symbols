=== /user.jump ===
// Error, can't re-export something that's only a type.
export { T } from "./exportT";
>T : Symbol(T, Decl(user.jump, 1, 8))

export import T2 = require("./exportEqualsT");
>T2 : Symbol(T2, Decl(user.jump, 1, 30))

// OK, has a value side
export { C } from "./exportValue";
>C : Symbol(C, Decl(user.jump, 5, 8))

// OK, even though the namespace it exports is only types.
import * as NS from "./exportT";
>NS : Symbol(NS, Decl(user.jump, 8, 6))

export { NS };
>NS : Symbol(NS, Decl(user.jump, 9, 8))

// OK, syntactically clear that a type is being re-exported.
export type T3 = T;
>T3 : Symbol(T3, Decl(user.jump, 9, 14))
>T : Symbol(T, Decl(user.jump, 15, 8))

// Error, not clear (to an isolated module) whether `T4` is a type.
import { T } from "./exportT";
>T : Symbol(T, Decl(user.jump, 15, 8))

export { T as T4 };
>T : Symbol(T4, Decl(user.jump, 16, 8))
>T4 : Symbol(T4, Decl(user.jump, 16, 8))

=== /exportT.jump ===
export type T = number;
>T : Symbol(T, Decl(exportT.jump, 0, 0))

=== /exportValue.jump ===
export class C {}
>C : Symbol(C, Decl(exportValue.jump, 0, 0))

=== /exportEqualsT.jump ===
declare type T = number;
>T : Symbol(T, Decl(exportEqualsT.jump, 0, 0))

export = T;
>T : Symbol(T, Decl(exportEqualsT.jump, 0, 0))

