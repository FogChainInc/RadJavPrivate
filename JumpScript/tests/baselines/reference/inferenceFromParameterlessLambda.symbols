=== tests/cases/compiler/inferenceFromParameterlessLambda.jump ===
function foo<T>(o: Take<T>, i: Make<T>) { }
>foo : Symbol(foo, Decl(inferenceFromParameterlessLambda.jump, 0, 0))
>T : Symbol(T, Decl(inferenceFromParameterlessLambda.jump, 0, 13))
>o : Symbol(o, Decl(inferenceFromParameterlessLambda.jump, 0, 16))
>Take : Symbol(Take, Decl(inferenceFromParameterlessLambda.jump, 3, 1))
>T : Symbol(T, Decl(inferenceFromParameterlessLambda.jump, 0, 13))
>i : Symbol(i, Decl(inferenceFromParameterlessLambda.jump, 0, 27))
>Make : Symbol(Make, Decl(inferenceFromParameterlessLambda.jump, 0, 43))
>T : Symbol(T, Decl(inferenceFromParameterlessLambda.jump, 0, 13))

interface Make<T> {
>Make : Symbol(Make, Decl(inferenceFromParameterlessLambda.jump, 0, 43))
>T : Symbol(T, Decl(inferenceFromParameterlessLambda.jump, 1, 15))

    (): T;
>T : Symbol(T, Decl(inferenceFromParameterlessLambda.jump, 1, 15))
}
interface Take<T> {
>Take : Symbol(Take, Decl(inferenceFromParameterlessLambda.jump, 3, 1))
>T : Symbol(T, Decl(inferenceFromParameterlessLambda.jump, 4, 15))

    (n: T): void;
>n : Symbol(n, Decl(inferenceFromParameterlessLambda.jump, 5, 5))
>T : Symbol(T, Decl(inferenceFromParameterlessLambda.jump, 4, 15))
}
// Infer string from second argument because it isn't context sensitive
foo(n => n.length, () => 'hi');
>foo : Symbol(foo, Decl(inferenceFromParameterlessLambda.jump, 0, 0))
>n : Symbol(n, Decl(inferenceFromParameterlessLambda.jump, 8, 4))
>n.length : Symbol(String.length, Decl(lib.d.jump, --, --))
>n : Symbol(n, Decl(inferenceFromParameterlessLambda.jump, 8, 4))
>length : Symbol(String.length, Decl(lib.d.jump, --, --))

