diff --git a/CMakeLists.txt b/CMakeLists.txt
index efb5e3a..8722845 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -84,14 +84,16 @@ endif()
 
 find_package(Boost REQUIRED filesystem system regex)
 
-find_package(OGRE 1.8 REQUIRED)
+find_package(OGRE 1.10.11 REQUIRED)
 
 include_directories( SYSTEM ${COLLADAFW_INCLUDE_DIR} ${COLLADASAX_INCLUDE_DIR} ${COLLADA_GENERATED_SAX_INCLUDE_DIR} ${COLLADABASE_INCLUDE_DIR} ${OGRE_INCLUDE_DIRS} )
 
-if (CMAKE_COMPILER_IS_GNUCXX)
+#if (CMAKE_COMPILER_IS_GNUCXX)
   # for unique_ptr, at least, and possibly other things (lambdas, move semantics)
-  add_definitions(-std=c++0x -Wall)
-endif()
+#  add_definitions(-std=c++0x -Wall)
+#endif()
+
+add_definitions(-std=c++11 -Wall)
 
 # make a library out of the Collada stuff
 add_library(collada_importer OgreMeshWriter.cpp OgreSceneWriter.cpp OgreColladaWriter.cpp OgreColladaSaxLoader.cpp)
diff --git a/OgreColladaWriter.cpp b/OgreColladaWriter.cpp
index 1d93a7e..57bc8e5 100644
--- a/OgreColladaWriter.cpp
+++ b/OgreColladaWriter.cpp
@@ -563,7 +563,7 @@ bool OgreCollada::Writer::writeImage(const COLLADAFW::Image* i) {
     // Ogre wants to load base name files (without paths) from directories that have already been registered.
     // We normally see our textures in subdirectories.  Trim off the path
     Ogre::TexturePtr texture = Ogre::TextureManager::getSingleton().load(image_rel_path, "General");
-    if (texture.isNull()) {
+    if (!texture) {
       LOG_DEBUG("COLLADA WARNING: Failed to load texture from file " + image_rel_path);
     } else {
       m_images.insert(std::make_pair(i->getUniqueId(), texture->getName()));
diff --git a/OgreMeshWriter.cpp b/OgreMeshWriter.cpp
index 3944d43..c7723ad 100644
--- a/OgreMeshWriter.cpp
+++ b/OgreMeshWriter.cpp
@@ -62,12 +62,14 @@ void OgreCollada::MeshWriter::pass1Finish() {
     createSceneDFS(m_vsRootNodes[i], xform);
   }
 
+  createMaterials();
+
   // create manualobject for use by pass2 writeGeometry calls
   m_manobj = new Ogre::ManualObject(m_vsRootNodes[0]->getName() + "_mobj");
 }
 
 void OgreCollada::MeshWriter::finish() {
-  createMaterials();
+  //createMaterials();
 
   // close manualobject and convert to mesh
   m_mesh = m_manobj->convertToMesh(m_vsRootNodes[0]->getName() + "_mesh");
diff --git a/collada2ogre.cpp b/collada2ogre.cpp
index 1912e0d..2aaed65 100644
--- a/collada2ogre.cpp
+++ b/collada2ogre.cpp
@@ -28,6 +28,7 @@ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLI
 #include <OgreRenderWindow.h>
 
 #include "OgreMeshWriter.h"
+#include <iostream>
 
 #define LOG_DEBUG(msg) { Ogre::LogManager::getSingleton().logMessage( Ogre::String((msg)) ); }
 
@@ -64,6 +65,7 @@ public:
 
 int main(int argc, char *argv[])
 {
+	/*
   Ogre::Root root;
   Ogre::RenderSystemList rlist = root.getAvailableRenderers();
   for (size_t i = 0; i < rlist.size(); ++i) {
@@ -79,6 +81,29 @@ int main(int argc, char *argv[])
   root.initialise(false);      // we specify our own window
   root.getRenderSystem()->setConfigOption("RTT Preferred Mode", "PBuffer");  // bug workaround in nVidia drivers
   root.createRenderWindow("ignore me", 80, 80, false);
+*/
+	Ogre::Root* root = Ogre::Root::getSingletonPtr();
+	if(!root)
+		root = new Ogre::Root("plugins.cfg", "ogre.cfg", "log.txt");
+	
+	if(!root->restoreConfig())
+	{
+		if(root->showConfigDialog(/* OgreBites::getNativeConfigDialog()*/))
+		{
+		}
+	}
+	
+	Ogre::ResourceGroupManager::getSingleton().initialiseAllResourceGroups();
+	
+	Ogre::RenderWindow *rwindow = nullptr;
+	
+	try {
+		rwindow = root->initialise(true, "Ogre");
+	}
+	catch(Ogre::Exception e)
+	{
+		std::cerr << e.what();
+	}
 
   // open logger
   Ogre::LogManager::getSingleton().createLog("collada2ogre.log", true);
@@ -131,7 +156,7 @@ int main(int argc, char *argv[])
   matser.exportQueued(matpath.string());
 
   Ogre::MeshPtr mesh = writer.getMesh();
-  if (mesh.isNull()) {
+  if (!mesh) {
     LOG_DEBUG("no mesh created.  exiting.");
     return 1;
   }
diff --git a/test/cube_test.cpp b/test/cube_test.cpp
index 63ed0a4..e1e2845 100644
--- a/test/cube_test.cpp
+++ b/test/cube_test.cpp
@@ -81,7 +81,7 @@ BOOST_AUTO_TEST_CASE( basic_contents ) {
   Ogre::Entity* ent = sceneMgr->getEntity("Cube:CubeID");
   BOOST_REQUIRE(ent);
   Ogre::MeshPtr mesh = ent->getMesh();
-  BOOST_REQUIRE(!mesh.isNull());
+  BOOST_REQUIRE(!(!mesh));
   BOOST_CHECK_EQUAL(1, mesh->getNumSubMeshes());
   Ogre::SubEntity* subent = ent->getSubEntity(0);
   BOOST_REQUIRE(subent);
