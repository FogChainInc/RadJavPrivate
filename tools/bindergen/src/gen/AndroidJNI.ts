import { Bindergen } from "./Bindergen";
import { Generator } from "./Generator";
import { GeneratorReference } from "./GeneratorReference";
import { GeneratorClass } from "./GeneratorClass";
import { GeneratorFunction } from "./GeneratorFunction";
import { GeneratorFunctionArgument } from "./GeneratorFunctionArgument";
import * as utils from "./utils";
import * as cheerio from "cheerio";
import { GeneratorOutput } from "../GeneratorOutput";

function fixGenericHTML (str: string): string
{
	str = str.replace (/\&\lt\;/g, "<");
	str = str.replace (/\&\gt\;/g, ">");

	return (str);
}

function getJNISignatureDataType (dataType: string)
{
	dataType = utils.removeWhitespaces (dataType);
	dataType = fixGenericHTML (dataType);
	dataType = dataType.replace (/\<(.*?)\>/g, "");
	let pos: number = dataType.indexOf ("final ");

	if (pos > -1)
	{
		debugger;
		dataType = dataType.replace (/(s|final )/g, "");
	}

	if (dataType == "void")
		return ("V");

	if (dataType == "boolean")
		return ("Z");

	if (dataType == "byte")
		return ("B");

	if (dataType == "char")
		return ("C");

	if (dataType == "short")
		return ("S");

	if (dataType == "int")
		return ("I");

	if (dataType == "long")
		return ("J");

	if (dataType == "float")
		return ("F");

	if (dataType == "double")
		return ("D");

	let str: string = "";
	pos = dataType.indexOf ("[]");

	if (pos > -1)
	{
		dataType = dataType.substring (0, pos - 1);
		str = "[" + getJNISignatureDataType (dataType);
	}

	str = `L${dataType};`;

	return (str);
}

var jni = new Generator ("AndroidJNI");
var reference: GeneratorReference = new GeneratorReference ();
reference.path = Bindergen.getArg ("android-docs");
reference.on ("classReference", async function (genClass: GeneratorClass)
	{
		let classes: string[] = GeneratorClass.getClassFromString (genClass.getName());
		let path: string = "";

		for (let iIdx = 0; iIdx < classes.length; iIdx++)
		{
			if (iIdx == (classes.length - 1))
				path += classes[iIdx] + ".html";
			else
				path += classes[iIdx] + "/";
		}

		try
		{
			let contents: string = await this.lookup ("/reference/" + path);

			let $ = cheerio.load (contents);
			let pubmethods = $("#pubmethods tr");

			for (let iIdx = 0; iIdx < pubmethods.length; iIdx++)
			{
				if (iIdx == 0)	// Skip the Public Methods table header.
					continue;

				let returnType = $(pubmethods[iIdx]).find ("td code")[0];
				let method = $(pubmethods[iIdx]).find ("td code")[1];
				let methodName = $(method).find ("a")[0];
				let returnTypeHTML = $(returnType).html ();

				let func: GeneratorFunction = new GeneratorFunction ();
				func.on ("generate", function (type: string, data: string)
					{
						debugger;
						let content: string = 
							`nativeSetText = env->GetMethodID(${data}, "${this.name}", "(Ljava/lang/CharSequence;)V");`;

						return (content);
					});

				func.name = utils.removeWhitespaces ($(methodName).html ());

				if (returnTypeHTML.search (/(s|final\s)/g) > -1)
					returnTypeHTML = returnTypeHTML.replace (/(s|final\s)/g, "");

				func.returns = utils.removeWhitespaces (returnTypeHTML);

				let args: string = $(method).html ();
				let argsStart = args.indexOf ("(");
				let argsEnd = args.indexOf (")");
				let argsStr: string = args.substring (argsStart, argsEnd + 1);
				let realArgs: string[] = argsStr.match (/(?<=[\(,])[^\),]*(,)*()/g);

				for (let iJdx = 0; iJdx < realArgs.length; iJdx++)
				{
					let tempStr: string = realArgs[iJdx];
					let foundArg: string = "";

					foundArg = fixGenericHTML (tempStr);
					func.arguments.push (new GeneratorFunctionArgument ("", foundArg));
				}

				// Create the JNI signature.
				func.data = "(";

				for (let iJdx = 0; iJdx < func.arguments.length; iJdx++)
				{
					let arg: GeneratorFunctionArgument = func.arguments[iJdx];

					func.data += getJNISignatureDataType(arg.dataType);
				}

				func.data += ")" + getJNISignatureDataType (returnTypeHTML);
				genClass.addFunction (func);
			}
		}
		catch (ex)
		{
			throw new Error (ex.message);
		}
	});
jni.referFrom (reference);
jni.createKeyword ("jniType", "");
let jniHeaders: GeneratorOutput = jni.createOutput ("jniHeaders");
let jniCreate: GeneratorOutput = jni.createOutput ("jniCreate");
jniHeaders.on ("first", function (output: GeneratorOutput)
	{
		let content = `// --- AUTOGENERATED CODE DO NOT MODIFY ---
		static jclass native%jniType%Class;
		static jmethodID native%jniType%Constructor;
`;
		return (content);
	});
jniCreate.on ("first", function (output: GeneratorOutput)
	{
		let content = `// --- AUTOGENERATED CODE DO NOT MODIFY ---`;

		return (content);
	});
jniCreate.on ("start", function ()
	{
		let content = `
		if (!nativeButtonClass)
		{
			Jni& jni = Jni::instance();
			JNIEnv* env = jni.getJniEnv();

			nativeButtonClass = jni.findClass("android/widget/Button");
			nativeConstructor = env->GetMethodID(nativeButtonClass, "<init>", "(Landroid/content/Context;)V");`;

		return (content);
	});
jniCreate.on ("end", function ()
	{
		let content = `
		}
`;

		return (content);
	});
jniCreate.on ("functionCall", function (func, ...args)
	{
		debugger;
		let content = func.generate ("jniCreate", "nativeButtonClass");

		return (content);
	});

module.exports = jni;